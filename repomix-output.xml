This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
.worktrees/
  quota-page/
    .claude/
      settings.local.json
    app/
      api/
        channel-stats/
          route.ts
        live-chat-id/
          route.ts
        messages/
          db/
            route.ts
          stream/
            route.ts
          route.ts
        overlay/
          route.ts
        quota/
          route.ts
        videos/
          route.ts
      obs/
        page.module.css
        page.tsx
      overview/
        page.module.css
        page.tsx
      quota/
        page.module.css
        page.tsx
      transmissions/
        page.module.css
        page.tsx
      videos/
        page.module.css
        page.tsx
      globals.css
      layout.tsx
      page.tsx
    components/
      Navigation.module.css
      Navigation.tsx
    docs/
      plans/
        2025-12-07-overlay-moderation-design.md
        2025-12-23-quota-page-design.md
      youtube-api-quota.md
    lib/
      api-logger-client.ts
      api-logger.ts
      database.ts
      db-init.ts
      youtube-api.ts
    src/
      utils/
        database.ts
        youtube-api.ts
      get-channel-data.ts
      index.ts
      test-channel-serejaris.ts
      test-connection.ts
    .env.example
    .git
    .gitignore
    CLAUDE.md
    next.config.js
    package.json
    plan.md
    README.md
    tsconfig.json
app/
  api/
    channel-stats/
      route.ts
    live-chat-id/
      route.ts
    messages/
      db/
        route.ts
      stream/
        route.ts
      route.ts
    overlay/
      route.ts
    quota/
      route.ts
    videos/
      route.ts
  obs/
    page.module.css
    page.tsx
  overview/
    page.module.css
    page.tsx
  quota/
    page.module.css
    page.tsx
  transmissions/
    page.module.css
    page.tsx
  videos/
    page.module.css
    page.tsx
  globals.css
  layout.tsx
  page.tsx
components/
  Navigation.module.css
  Navigation.tsx
docs/
  plans/
    2025-12-07-overlay-moderation-design.md
    2025-12-23-quota-page-design.md
  youtube-api-quota.md
lib/
  api-logger-client.ts
  api-logger.ts
  database.ts
  db-init.ts
  youtube-api.ts
src/
  utils/
    database.ts
    youtube-api.ts
  get-channel-data.ts
  index.ts
  test-channel-serejaris.ts
  test-connection.ts
.env.example
.gitignore
CLAUDE.md
next.config.js
package.json
plan.md
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".worktrees/quota-page/.claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Skill(superpowers:brainstorming)"
    ],
    "deny": [],
    "ask": []
  }
}
</file>

<file path=".worktrees/quota-page/app/api/channel-stats/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createYoutubeClient, getChannelStats } from "@/lib/youtube-api";

export async function GET(request: NextRequest) {
  const apiKey = process.env.YOUTUBE_API_KEY;
  const channelId = process.env.YOUTUBE_CHANNEL_ID;

  if (!apiKey) {
    return NextResponse.json({ error: "YOUTUBE_API_KEY отсутствует в окружении" }, { status: 500 });
  }

  if (!channelId) {
    return NextResponse.json({ error: "YOUTUBE_CHANNEL_ID отсутствует в окружении" }, { status: 500 });
  }

  try {
    const youtube = createYoutubeClient(apiKey);
    const stats = await getChannelStats(youtube, channelId);
    
    if (!stats) {
      return NextResponse.json({ error: "Канал не найден" }, { status: 404 });
    }
    
    return NextResponse.json(stats);
  } catch (error) {
    const message = error instanceof Error ? error.message : "Неизвестная ошибка";
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
</file>

<file path=".worktrees/quota-page/app/api/live-chat-id/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createYoutubeClient, getLiveBroadcasts, getLiveChatId } from "@/lib/youtube-api";

export async function GET(request: NextRequest) {
  const apiKey = process.env.YOUTUBE_API_KEY;
  const channelId = process.env.YOUTUBE_CHANNEL_ID;

  if (!apiKey) {
    return NextResponse.json({ error: "YOUTUBE_API_KEY отсутствует в окружении" }, { status: 500 });
  }

  if (!channelId) {
    return NextResponse.json({ error: "YOUTUBE_CHANNEL_ID отсутствует в окружении" }, { status: 500 });
  }

  try {
    const youtube = createYoutubeClient(apiKey);
    const broadcasts = await getLiveBroadcasts(youtube, channelId);
    const liveVideo = broadcasts.find((item) => item.id?.videoId);
    
    if (!liveVideo?.id?.videoId) {
      return NextResponse.json({ error: "Активная трансляция не найдена" }, { status: 404 });
    }
    
    const liveChatId = await getLiveChatId(youtube, liveVideo.id.videoId);
    if (!liveChatId) {
      return NextResponse.json({ error: "Live Chat ID не найден" }, { status: 404 });
    }
    
    return NextResponse.json({
      liveChatId,
      videoId: liveVideo.id.videoId,
      title: liveVideo.snippet?.title ?? "",
      scheduledStartTime: liveVideo.snippet?.publishedAt ?? null,
    });
  } catch (error) {
    const message = error instanceof Error ? error.message : "Неизвестная ошибка";
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
</file>

<file path=".worktrees/quota-page/app/api/messages/db/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getMessages } from "@/lib/database";
import { ensureDatabaseInitialized } from "@/lib/db-init";

export async function GET(request: NextRequest) {
  try {
    await ensureDatabaseInitialized();
    const searchParams = request.nextUrl.searchParams;
    const limit = Number(searchParams.get("limit") || 100);
    const offset = Number(searchParams.get("offset") || 0);
    const videoId = searchParams.get("videoId") || undefined;
    
    const messages = await getMessages(limit, offset, videoId);
    return NextResponse.json({
      messages: messages.map((msg) => ({
        author: msg.authorName,
        text: msg.messageText,
        time: new Date(msg.publishedAt).toLocaleTimeString("ru-RU", { hour12: false }),
        publishedAt: msg.publishedAt.toISOString(),
      })),
    });
  } catch (error) {
    const message = error instanceof Error ? error.message : "Неизвестная ошибка";
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
</file>

<file path=".worktrees/quota-page/app/api/messages/stream/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createYoutubeClient, fetchMessages, formatMessage } from "@/lib/youtube-api";
import { saveMessages } from "@/lib/database";
import { ensureDatabaseInitialized } from "@/lib/db-init";

export async function GET(request: NextRequest) {
  const apiKey = process.env.YOUTUBE_API_KEY;
  
  if (!apiKey) {
    return NextResponse.json({ error: "YOUTUBE_API_KEY отсутствует в окружении" }, { status: 500 });
  }

  const searchParams = request.nextUrl.searchParams;
  const liveChatId = searchParams.get("liveChatId");
  const videoId = searchParams.get("videoId");
  
  if (!liveChatId || liveChatId.length === 0) {
    return NextResponse.json({ error: "Параметр liveChatId обязателен" }, { status: 400 });
  }
  
  const encoder = new TextEncoder();
  const stream = new ReadableStream({
    async start(controller) {
      const youtube = createYoutubeClient(apiKey);
      let nextPageToken: string | undefined = undefined;
      let pollingInterval = 2000;
      let timer: NodeJS.Timeout | null = null;
      
      const poll = async () => {
        try {
          await ensureDatabaseInitialized();
          const data = await fetchMessages(youtube, liveChatId, nextPageToken);
          const items = data.items ?? [];
          const formattedMessages = items.map((item) => formatMessage(item));
          
          if (formattedMessages.length > 0) {
            const messagesToSave = formattedMessages.map((msg) => ({
              messageId: msg.messageId,
              videoId: videoId || undefined,
              liveChatId,
              authorName: msg.author,
              messageText: msg.text,
              publishedAt: msg.publishedAt,
            }));
            await saveMessages(messagesToSave);
            
            const messagesToSend = formattedMessages.map(({ messageId, publishedAt, ...rest }) => rest);
            const jsonData = JSON.stringify({ messages: messagesToSend });
            controller.enqueue(encoder.encode(`data: ${jsonData}\n\n`));
          }
          
          nextPageToken = data.nextPageToken ?? undefined;
          pollingInterval = data.pollingIntervalMillis ?? 2000;
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : "Неизвестная ошибка";
          controller.enqueue(encoder.encode(`data: ${JSON.stringify({ error: errorMessage })}\n\n`));
        }
        
        timer = setTimeout(poll, pollingInterval);
      };
      
      poll();
      
      request.signal.addEventListener("abort", () => {
        if (timer) {
          clearTimeout(timer);
        }
        controller.close();
      });
    },
  });
  
  return new Response(stream, {
    headers: {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      "Connection": "keep-alive",
    },
  });
}
</file>

<file path=".worktrees/quota-page/app/api/messages/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createYoutubeClient, fetchMessages, formatMessage } from "@/lib/youtube-api";
import { saveMessages } from "@/lib/database";
import { ensureDatabaseInitialized } from "@/lib/db-init";

export async function GET(request: NextRequest) {
  const apiKey = process.env.YOUTUBE_API_KEY;
  
  if (!apiKey) {
    return NextResponse.json({ error: "YOUTUBE_API_KEY отсутствует в окружении" }, { status: 500 });
  }

  const searchParams = request.nextUrl.searchParams;
  const liveChatId = searchParams.get("liveChatId");
  const pageToken = searchParams.get("pageToken");
  const videoId = searchParams.get("videoId");

  if (!liveChatId || liveChatId.length === 0) {
    return NextResponse.json({ error: "Параметр liveChatId обязателен" }, { status: 400 });
  }

  try {
    await ensureDatabaseInitialized();
    const youtube = createYoutubeClient(apiKey);
    const data = await fetchMessages(youtube, liveChatId, pageToken || undefined);
    const items = data.items ?? [];
    const formattedMessages = items.map((item) => formatMessage(item));
    
    if (formattedMessages.length > 0) {
      const messagesToSave = formattedMessages.map((msg) => ({
        messageId: msg.messageId,
        videoId: videoId || undefined,
        liveChatId,
        authorName: msg.author,
        messageText: msg.text,
        publishedAt: msg.publishedAt,
      }));
      await saveMessages(messagesToSave);
    }
    
    return NextResponse.json({
      messages: formattedMessages.map(({ messageId, publishedAt, ...rest }) => rest),
      nextPageToken: data.nextPageToken ?? null,
      pollingIntervalMillis: data.pollingIntervalMillis ?? 2000,
    });
  } catch (error) {
    const message = error instanceof Error ? error.message : "Неизвестная ошибка";
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
</file>

<file path=".worktrees/quota-page/app/api/overlay/route.ts">
import { NextResponse } from "next/server";

interface OverlayMessage {
  id: string;
  author: string;
  authorPhoto?: string;
  message: string;
  timestamp: number;
}

let currentOverlay: OverlayMessage | null = null;

export async function GET() {
  return NextResponse.json({ overlay: currentOverlay });
}

export async function POST(request: Request) {
  try {
    const body = await request.json();

    if (!body.author || !body.message) {
      return NextResponse.json(
        { error: "author and message are required" },
        { status: 400 }
      );
    }

    currentOverlay = {
      id: body.id || `${Date.now()}`,
      author: body.author,
      authorPhoto: body.authorPhoto,
      message: body.message,
      timestamp: Date.now(),
    };

    return NextResponse.json({ overlay: currentOverlay });
  } catch {
    return NextResponse.json(
      { error: "Invalid request body" },
      { status: 400 }
    );
  }
}

export async function DELETE() {
  currentOverlay = null;
  return NextResponse.json({ overlay: null });
}
</file>

<file path=".worktrees/quota-page/app/api/quota/route.ts">
import { NextResponse } from "next/server";
import { Pool } from "pg";

const pool = new Pool({
  host: process.env.DB_HOST || "localhost",
  port: Number(process.env.DB_PORT || 5432),
  database: process.env.DB_NAME || "yt_chat",
  user: process.env.DB_USER || "postgres",
  password: process.env.DB_PASSWORD || "",
});

const DAILY_LIMIT = 10000;

export async function GET() {
  const client = await pool.connect();
  try {
    const todayStats = await client.query(`
      SELECT COALESCE(SUM(quota_cost), 0) as total_used
      FROM api_request_logs
      WHERE timestamp >= (NOW() AT TIME ZONE 'America/Los_Angeles')::date
                         AT TIME ZONE 'America/Los_Angeles'
    `);

    const byEndpoint = await client.query(`
      SELECT
        endpoint_type,
        COUNT(*)::int as count,
        SUM(quota_cost)::int as total_cost
      FROM api_request_logs
      WHERE timestamp >= (NOW() AT TIME ZONE 'America/Los_Angeles')::date
                         AT TIME ZONE 'America/Los_Angeles'
      GROUP BY endpoint_type
      ORDER BY total_cost DESC
    `);

    const used = Number(todayStats.rows[0].total_used);

    return NextResponse.json({
      today: {
        used,
        limit: DAILY_LIMIT,
      },
      byEndpoint: byEndpoint.rows.map((row) => ({
        endpoint: row.endpoint_type,
        count: row.count,
        cost: row.total_cost,
      })),
    });
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    return NextResponse.json({ error: message }, { status: 500 });
  } finally {
    client.release();
  }
}
</file>

<file path=".worktrees/quota-page/app/api/videos/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createYoutubeClient, getChannelVideosWithDetails } from "@/lib/youtube-api";

export async function GET(request: NextRequest) {
  const apiKey = process.env.YOUTUBE_API_KEY;
  const channelId = process.env.YOUTUBE_CHANNEL_ID;

  if (!apiKey) {
    return NextResponse.json({ error: "YOUTUBE_API_KEY отсутствует в окружении" }, { status: 500 });
  }

  if (!channelId) {
    return NextResponse.json({ error: "YOUTUBE_CHANNEL_ID отсутствует в окружении" }, { status: 500 });
  }

  try {
    const youtube = createYoutubeClient(apiKey);
    const searchParams = request.nextUrl.searchParams;
    const maxResults = parseInt(searchParams.get("maxResults") || "50", 10);
    
    const videos = await getChannelVideosWithDetails(youtube, channelId, maxResults);
    
    return NextResponse.json({ videos });
  } catch (error) {
    let message = "Неизвестная ошибка";
    
    if (error instanceof Error) {
      message = error.message;
      if (message.includes("quota") || message.includes("exceeded")) {
        message = "Превышена квота YouTube API. Попробуйте позже или проверьте настройки API ключа.";
      } else if (message.includes("API key")) {
        message = "Неверный API ключ YouTube. Проверьте настройки окружения.";
      }
    }
    
    console.error("Ошибка при получении видео:", error);
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
</file>

<file path=".worktrees/quota-page/app/obs/page.module.css">
.container {
  width: 100%;
  height: 100vh;
  padding: 16px;
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
  background: transparent;
}

.messages {
  list-style: none;
  display: flex;
  flex-direction: column;
  gap: 12px;
  max-height: 100%;
  overflow-y: auto;
}

.message {
  display: flex;
  flex-direction: column;
  gap: 4px;
  padding: 12px 16px;
  background: rgba(0, 0, 0, 0.75);
  border-radius: 8px;
  border-left: 3px solid #38bdf8;
  backdrop-filter: blur(8px);
  animation: slideIn 0.3s ease-out;
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.messageHeader {
  display: flex;
  align-items: center;
  gap: 8px;
}

.messageAuthor {
  font-weight: 600;
  color: #38bdf8;
  font-size: 14px;
}

.messageTime {
  font-size: 12px;
  color: rgba(255, 255, 255, 0.6);
}

.messageText {
  font-size: 14px;
  line-height: 1.5;
  color: #ffffff;
  word-wrap: break-word;
}

.messages::-webkit-scrollbar {
  width: 4px;
}

.messages::-webkit-scrollbar-track {
  background: transparent;
}

.messages::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.2);
  border-radius: 2px;
}

/* Overlay styles */
.overlay {
  position: fixed;
  bottom: 24px;
  left: 24px;
  right: 24px;
  padding: 20px 24px;
  background: rgba(0, 0, 0, 0.85);
  border-radius: 12px;
  border-left: 4px solid #38bdf8;
  backdrop-filter: blur(12px);
  transition: opacity 0.3s ease, transform 0.3s ease;
  z-index: 1000;
}

.overlayVisible {
  opacity: 1;
  transform: translateY(0);
}

.overlayHidden {
  opacity: 0;
  transform: translateY(20px);
}

.overlayAuthor {
  font-weight: 700;
  font-size: 28px;
  color: #38bdf8;
  margin-bottom: 12px;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
}

.overlayText {
  font-size: 32px;
  line-height: 1.4;
  color: #ffffff;
  word-wrap: break-word;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
}

.cursor {
  animation: blink 0.7s infinite;
  color: #38bdf8;
  font-weight: 300;
}

@keyframes blink {
  0%, 50% {
    opacity: 1;
  }
  51%, 100% {
    opacity: 0;
  }
}
</file>

<file path=".worktrees/quota-page/app/obs/page.tsx">
"use client";

import { useEffect, useState, useRef, useCallback } from "react";
import styles from "./page.module.css";

interface Message {
  time: string;
  author: string;
  text: string;
}

interface OverlayMessage {
  id: string;
  author: string;
  message: string;
  timestamp: number;
}

export default function OBSPage() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [overlayMessage, setOverlayMessage] = useState<OverlayMessage | null>(null);
  const [displayedText, setDisplayedText] = useState("");
  const [isTyping, setIsTyping] = useState(false);
  const [isVisible, setIsVisible] = useState(false);
  const lastOverlayIdRef = useRef<string | null>(null);
  const [isMonitoringEnabled, setIsMonitoringEnabled] = useState(() => {
    if (typeof window !== "undefined") {
      const saved = localStorage.getItem("obsMonitoringEnabled");
      return saved !== null ? saved === "true" : true;
    }
    return true;
  });

  const eventSourceRef = useRef<EventSource | null>(null);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const checkStreamTimerRef = useRef<NodeJS.Timeout | null>(null);
  const retryDelayRef = useRef<number>(5000);
  const isMountedRef = useRef<boolean>(true);
  const abortControllerRef = useRef<AbortController | null>(null);
  const checkForStreamRef = useRef<(() => Promise<void>) | null>(null);

  useEffect(() => {
    if (typeof window !== "undefined") {
      localStorage.setItem("obsMonitoringEnabled", String(isMonitoringEnabled));
    }
  }, [isMonitoringEnabled]);

  // Polling for overlay messages
  useEffect(() => {
    const pollOverlay = async () => {
      try {
        const response = await fetch("/api/overlay");
        if (response.ok) {
          const data = await response.json();
          const newOverlay = data.overlay as OverlayMessage | null;

          if (newOverlay && newOverlay.id !== lastOverlayIdRef.current) {
            lastOverlayIdRef.current = newOverlay.id;
            setOverlayMessage(newOverlay);
            setDisplayedText("");
            setIsTyping(true);
            setIsVisible(true);
          } else if (!newOverlay && lastOverlayIdRef.current) {
            lastOverlayIdRef.current = null;
            setIsVisible(false);
            setTimeout(() => {
              setOverlayMessage(null);
              setDisplayedText("");
            }, 300);
          }
        }
      } catch (error) {
        console.error("Failed to fetch overlay:", error);
      }
    };

    pollOverlay();
    const interval = setInterval(pollOverlay, 1500);
    return () => clearInterval(interval);
  }, []);

  // Typewriter effect
  useEffect(() => {
    if (!overlayMessage || !isTyping) return;

    const text = overlayMessage.message;
    let index = 0;

    const typeInterval = setInterval(() => {
      if (index < text.length) {
        setDisplayedText(text.slice(0, index + 1));
        index++;
      } else {
        setIsTyping(false);
        clearInterval(typeInterval);
      }
    }, 50);

    return () => clearInterval(typeInterval);
  }, [overlayMessage, isTyping]);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const appendMessage = (message: Message) => {
    setMessages((prev) => {
      const updated = [...prev, message];
      const maxMessages = 50;
      return updated.slice(-maxMessages);
    });
  };

  const stopStreaming = useCallback(() => {
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
      eventSourceRef.current = null;
    }
    setMessages([]);
  }, []);

  const startStreaming = useCallback(
    (payload: { liveChatId: string; videoId: string }) => {
      if (!isMountedRef.current || !isMonitoringEnabled || document.hidden) {
        return;
      }

      const { liveChatId, videoId } = payload;

      if (liveChatId && videoId) {
        const url = `/api/messages/stream?liveChatId=${encodeURIComponent(liveChatId)}&videoId=${encodeURIComponent(videoId)}`;
        const eventSource = new EventSource(url);
        eventSourceRef.current = eventSource;

        eventSource.onmessage = (event) => {
          if (!isMountedRef.current) return;
          try {
            const data = JSON.parse(event.data);
            if (data.messages && Array.isArray(data.messages)) {
              data.messages.forEach((msg: Message) => appendMessage(msg));
            }
          } catch (error) {
            console.error("Failed to parse SSE message:", error);
          }
        };

        eventSource.onerror = () => {
          if (!isMountedRef.current) return;
          eventSource.close();
          eventSourceRef.current = null;

          if (isMonitoringEnabled && !document.hidden && isMountedRef.current && checkForStreamRef.current) {
            checkStreamTimerRef.current = setTimeout(() => {
              checkForStreamRef.current?.();
            }, 5000);
          }
        };
      }
    },
    [isMonitoringEnabled]
  );

  const scheduleNextCheck = useCallback(() => {
    if (checkStreamTimerRef.current) {
      clearTimeout(checkStreamTimerRef.current);
      checkStreamTimerRef.current = null;
    }

    if (
      isMonitoringEnabled &&
      !document.hidden &&
      isMountedRef.current &&
      !eventSourceRef.current &&
      checkForStreamRef.current
    ) {
      checkStreamTimerRef.current = setTimeout(() => {
        checkForStreamRef.current?.();
      }, retryDelayRef.current);
    }
  }, [isMonitoringEnabled]);

  const checkForStream = useCallback(async () => {
    if (!isMonitoringEnabled || document.hidden || !isMountedRef.current) {
      return;
    }

    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    abortControllerRef.current = new AbortController();

    try {
      const response = await fetch("/api/live-chat-id", {
        signal: abortControllerRef.current.signal,
      });

      if (!response.ok) {
        throw new Error("live chat id not found");
      }

      const payload = await response.json();
      retryDelayRef.current = 5000;
      startStreaming(payload);
    } catch (error: any) {
      if (error.name === "AbortError") {
        return;
      }

      if (!isMountedRef.current) return;

      retryDelayRef.current = Math.min(retryDelayRef.current * 2, 30000);
      scheduleNextCheck();
    }
  }, [isMonitoringEnabled, startStreaming, scheduleNextCheck]);

  useEffect(() => {
    checkForStreamRef.current = checkForStream;
  }, [checkForStream]);

  useEffect(() => {
    isMountedRef.current = true;

    if (isMonitoringEnabled && checkForStreamRef.current) {
      checkForStreamRef.current();
    }

    return () => {
      isMountedRef.current = false;
      if (eventSourceRef.current) {
        eventSourceRef.current.close();
        eventSourceRef.current = null;
      }
      if (checkStreamTimerRef.current) {
        clearTimeout(checkStreamTimerRef.current);
        checkStreamTimerRef.current = null;
      }
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
        abortControllerRef.current = null;
      }
    };
  }, [isMonitoringEnabled]);

  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.hidden) {
        if (eventSourceRef.current) {
          eventSourceRef.current.close();
          eventSourceRef.current = null;
        }
        if (checkStreamTimerRef.current) {
          clearTimeout(checkStreamTimerRef.current);
          checkStreamTimerRef.current = null;
        }
        if (abortControllerRef.current) {
          abortControllerRef.current.abort();
          abortControllerRef.current = null;
        }
      } else if (isMonitoringEnabled && isMountedRef.current && checkForStreamRef.current) {
        retryDelayRef.current = 5000;
        checkForStreamRef.current();
      }
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);
    return () => {
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, [isMonitoringEnabled]);

  return (
    <div className={styles.container}>
      {overlayMessage && (
        <div className={`${styles.overlay} ${isVisible ? styles.overlayVisible : styles.overlayHidden}`}>
          <div className={styles.overlayAuthor}>{overlayMessage.author}</div>
          <div className={styles.overlayText}>
            {displayedText}
            {isTyping && <span className={styles.cursor}>|</span>}
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path=".worktrees/quota-page/app/overview/page.module.css">
.layout {
  width: min(960px, 100%);
  min-height: 100vh;
  margin: 0 auto;
  display: grid;
  grid-template-rows: auto 1fr;
  background: rgba(15, 23, 42, 0.85);
  border-radius: 16px;
  border: 1px solid rgba(148, 163, 184, 0.2);
  overflow: hidden;
  backdrop-filter: blur(16px);
}

.content {
  padding: 32px 24px;
}

.title {
  font-size: 28px;
  font-weight: 600;
  margin-bottom: 32px;
  color: var(--text);
}

.loading,
.error {
  padding: 24px;
  text-align: center;
  color: var(--text-muted);
}

.error {
  color: var(--error);
}

.stats {
  display: flex;
  flex-direction: column;
  gap: 32px;
}

.channelInfo {
  padding: 24px;
  background: rgba(30, 41, 59, 0.85);
  border-radius: 12px;
  border: 1px solid rgba(56, 189, 248, 0.1);
}

.channelTitle {
  font-size: 24px;
  font-weight: 600;
  color: var(--accent);
  margin-bottom: 12px;
}

.channelDescription {
  color: var(--text-muted);
  line-height: 1.6;
}

.metrics {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 20px;
}

.metric {
  padding: 24px;
  background: rgba(30, 41, 59, 0.85);
  border-radius: 12px;
  border: 1px solid rgba(56, 189, 248, 0.1);
  text-align: center;
}

.metricValue {
  font-size: 32px;
  font-weight: 700;
  color: var(--accent);
  margin-bottom: 8px;
}

.metricLabel {
  font-size: 14px;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

@media (max-width: 640px) {
  .layout {
    border-radius: 0;
    min-height: 100vh;
  }

  .content {
    padding: 24px 16px;
  }

  .metrics {
    grid-template-columns: 1fr;
  }
}
</file>

<file path=".worktrees/quota-page/app/overview/page.tsx">
"use client";

import { useEffect, useState } from "react";
import Navigation from "@/components/Navigation";
import styles from "./page.module.css";

interface ChannelStats {
  title: string;
  description: string;
  subscriberCount: string;
  videoCount: string;
  viewCount: string;
}

export default function OverviewPage() {
  const [stats, setStats] = useState<ChannelStats | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchStats = async () => {
      try {
        setLoading(true);
        const response = await fetch("/api/channel-stats");
        if (!response.ok) {
          throw new Error("Не удалось загрузить статистику");
        }
        const data = await response.json();
        setStats(data);
        setError(null);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Неизвестная ошибка");
      } finally {
        setLoading(false);
      }
    };

    fetchStats();
  }, []);

  const formatNumber = (num: string) => {
    const number = parseInt(num, 10);
    if (number >= 1000000) {
      return (number / 1000000).toFixed(1) + "M";
    }
    if (number >= 1000) {
      return (number / 1000).toFixed(1) + "K";
    }
    return number.toLocaleString("ru-RU");
  };

  return (
    <div className={styles.layout}>
      <Navigation />
      <main className={styles.content}>
        <h1 className={styles.title}>Обзор канала</h1>
        
        {loading && <div className={styles.loading}>Загрузка...</div>}
        
        {error && <div className={styles.error}>{error}</div>}
        
        {stats && (
          <div className={styles.stats}>
            <div className={styles.channelInfo}>
              <h2 className={styles.channelTitle}>{stats.title}</h2>
              {stats.description && (
                <p className={styles.channelDescription}>{stats.description}</p>
              )}
            </div>
            
            <div className={styles.metrics}>
              <div className={styles.metric}>
                <div className={styles.metricValue}>{formatNumber(stats.subscriberCount)}</div>
                <div className={styles.metricLabel}>Подписчиков</div>
              </div>
              
              <div className={styles.metric}>
                <div className={styles.metricValue}>{formatNumber(stats.viewCount)}</div>
                <div className={styles.metricLabel}>Просмотров</div>
              </div>
              
              <div className={styles.metric}>
                <div className={styles.metricValue}>{formatNumber(stats.videoCount)}</div>
                <div className={styles.metricLabel}>Видео</div>
              </div>
            </div>
          </div>
        )}
      </main>
    </div>
  );
}
</file>

<file path=".worktrees/quota-page/app/quota/page.module.css">
/* app/quota/page.module.css */
.layout {
  width: min(960px, 100%);
  min-height: 100vh;
  margin: 0 auto;
  display: grid;
  grid-template-rows: auto 1fr;
  background: rgba(15, 23, 42, 0.85);
  border-radius: 16px;
  border: 1px solid rgba(148, 163, 184, 0.2);
  overflow: hidden;
  backdrop-filter: blur(16px);
}

.content {
  padding: 32px 24px;
}

.title {
  font-size: 28px;
  font-weight: 600;
  margin-bottom: 32px;
  color: var(--text);
}

.loading,
.error,
.empty {
  padding: 24px;
  text-align: center;
  color: var(--text-muted);
}

.error {
  color: var(--error);
}

/* Counter section */
.counter {
  padding: 24px;
  background: rgba(30, 41, 59, 0.85);
  border-radius: 12px;
  border: 1px solid rgba(56, 189, 248, 0.1);
  margin-bottom: 32px;
}

.counterLabel {
  font-size: 14px;
  color: var(--text-muted);
  margin-bottom: 8px;
}

.counterValue {
  font-size: 32px;
  font-weight: 700;
  color: var(--accent);
  margin-bottom: 16px;
}

.counterValue span {
  font-size: 20px;
  font-weight: 400;
  color: var(--text-muted);
}

.progressBar {
  height: 8px;
  background: rgba(148, 163, 184, 0.2);
  border-radius: 4px;
  overflow: hidden;
}

.progressFill {
  height: 100%;
  background: var(--accent);
  transition: width 0.3s;
}

/* Endpoint table */
.section {
  margin-bottom: 24px;
}

.sectionTitle {
  font-size: 16px;
  font-weight: 500;
  color: var(--text-muted);
  margin-bottom: 16px;
}

.table {
  width: 100%;
  border-collapse: collapse;
}

.table th {
  text-align: left;
  padding: 12px 16px;
  font-size: 12px;
  font-weight: 500;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  border-bottom: 1px solid rgba(148, 163, 184, 0.2);
}

.table th:last-child {
  text-align: right;
}

.table td {
  padding: 12px 16px;
  border-bottom: 1px solid rgba(148, 163, 184, 0.1);
}

.table td:last-child {
  text-align: right;
  font-weight: 600;
}

.endpoint {
  font-family: "SF Mono", "Monaco", "Consolas", monospace;
  font-size: 14px;
  color: var(--text);
}

.count {
  color: var(--text-muted);
  font-size: 14px;
}

@media (max-width: 640px) {
  .layout {
    border-radius: 0;
  }

  .content {
    padding: 24px 16px;
  }
}
</file>

<file path=".worktrees/quota-page/app/quota/page.tsx">
// app/quota/page.tsx
"use client";

import { useEffect, useState } from "react";
import Navigation from "@/components/Navigation";
import styles from "./page.module.css";

interface QuotaStats {
  today: {
    used: number;
    limit: number;
  };
  byEndpoint: Array<{
    endpoint: string;
    count: number;
    cost: number;
  }>;
}

export default function QuotaPage() {
  const [stats, setStats] = useState<QuotaStats | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchStats = async () => {
      try {
        setLoading(true);
        const response = await fetch("/api/quota");
        if (!response.ok) {
          throw new Error("Не удалось загрузить статистику квоты");
        }
        const data = await response.json();
        setStats(data);
        setError(null);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Неизвестная ошибка");
      } finally {
        setLoading(false);
      }
    };

    fetchStats();
  }, []);

  const formatNumber = (num: number) => {
    return num.toLocaleString("ru-RU");
  };

  const getPercentage = () => {
    if (!stats) return 0;
    return Math.round((stats.today.used / stats.today.limit) * 100);
  };

  return (
    <div className={styles.layout}>
      <Navigation />
      <main className={styles.content}>
        <h1 className={styles.title}>Квота API</h1>

        {loading && <div className={styles.loading}>Загрузка...</div>}

        {error && <div className={styles.error}>{error}</div>}

        {stats && (
          <>
            <div className={styles.counter}>
              <div className={styles.counterLabel}>Использовано сегодня</div>
              <div className={styles.counterValue}>
                {formatNumber(stats.today.used)}{" "}
                <span>/ {formatNumber(stats.today.limit)} единиц</span>
              </div>
              <div className={styles.progressBar}>
                <div
                  className={styles.progressFill}
                  style={{ width: `${getPercentage()}%` }}
                />
              </div>
            </div>

            <div className={styles.section}>
              <h2 className={styles.sectionTitle}>Расход по операциям</h2>
              {stats.byEndpoint.length === 0 ? (
                <div className={styles.empty}>Нет данных за сегодня</div>
              ) : (
                <table className={styles.table}>
                  <thead>
                    <tr>
                      <th>Endpoint</th>
                      <th>Запросов</th>
                      <th>Стоимость</th>
                    </tr>
                  </thead>
                  <tbody>
                    {stats.byEndpoint.map((row) => (
                      <tr key={row.endpoint}>
                        <td className={styles.endpoint}>{row.endpoint}</td>
                        <td className={styles.count}>{row.count}</td>
                        <td>{formatNumber(row.cost)}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              )}
            </div>
          </>
        )}
      </main>
    </div>
  );
}
</file>

<file path=".worktrees/quota-page/app/transmissions/page.module.css">
.layout {
  width: min(960px, 100%);
  min-height: 100vh;
  margin: 0 auto;
  display: grid;
  grid-template-rows: auto auto 1fr auto;
  background: rgba(15, 23, 42, 0.85);
  border-radius: 16px;
  border: 1px solid rgba(148, 163, 184, 0.2);
  overflow: hidden;
  backdrop-filter: blur(16px);
}

.header,
.footer {
  padding: 20px 24px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: rgba(30, 41, 59, 0.8);
}

.streamInfo {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.streamStatus {
  font-size: 14px;
  color: var(--text-muted);
}

.streamTitle {
  font-size: 20px;
  font-weight: 600;
  color: var(--text);
}

.controls {
  display: flex;
  gap: 12px;
}

.controls button {
  background: var(--accent);
  color: #0b1120;
  border: none;
  padding: 10px 16px;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

.controls button:active {
  transform: scale(0.97);
}

.controls button:focus-visible {
  outline: 2px solid rgba(56, 189, 248, 0.6);
  outline-offset: 2px;
}

.monitoringActive {
  background: var(--accent) !important;
}

.monitoringInactive {
  background: rgba(148, 163, 184, 0.3) !important;
  color: var(--text-muted) !important;
}

.overlayPanel {
  padding: 12px 24px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: rgba(30, 41, 59, 0.6);
  border-bottom: 1px solid rgba(148, 163, 184, 0.1);
}

.overlayStatus {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
}

.overlayActive {
  color: var(--accent);
}

.overlayAuthor {
  color: var(--text);
  font-weight: 600;
}

.overlayEmpty {
  color: var(--text-muted);
}

.clearOverlayBtn {
  background: rgba(239, 68, 68, 0.2);
  color: #ef4444;
  border: 1px solid rgba(239, 68, 68, 0.3);
  padding: 6px 12px;
  border-radius: 6px;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.15s ease;
}

.clearOverlayBtn:hover {
  background: rgba(239, 68, 68, 0.3);
}

.content {
  padding: 24px;
  overflow-y: auto;
}

.messages {
  list-style: none;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.message {
  display: grid;
  grid-template-columns: auto 1fr auto;
  gap: 6px 12px;
  padding: 16px;
  background: rgba(30, 41, 59, 0.85);
  border-radius: 12px;
  border: 1px solid rgba(56, 189, 248, 0.1);
  box-shadow: 0 12px 32px rgba(15, 23, 42, 0.3);
  transition: border-color 0.2s ease;
}

.messageActive {
  border-color: var(--accent);
  background: rgba(56, 189, 248, 0.1);
}

.overlayBtn {
  background: transparent;
  border: none;
  font-size: 18px;
  cursor: pointer;
  opacity: 0.4;
  transition: opacity 0.15s ease, transform 0.15s ease;
  padding: 4px;
  grid-row: 1 / 2;
}

.overlayBtn:hover {
  opacity: 1;
  transform: scale(1.1);
}

.messageActive .overlayBtn {
  opacity: 1;
}

.message time {
  font-size: 13px;
  color: var(--text-muted);
}

.message strong {
  font-size: 15px;
  color: var(--accent);
}

.message p {
  grid-column: 1 / -1;
  white-space: pre-wrap;
  line-height: 1.55;
}

.footer {
  font-size: 14px;
  color: var(--text-muted);
}

.footerStatus {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.errorDetails {
  font-size: 12px;
  color: var(--error);
  opacity: 0.8;
  max-width: 600px;
  word-break: break-word;
}

.statusError {
  color: var(--error);
}

.apiIndicator {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 12px;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.apiDot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: rgba(148, 163, 184, 0.3);
  transition: all 0.2s ease;
}

.apiActive {
  background: var(--accent);
  box-shadow: 0 0 8px var(--accent);
  animation: pulse 1s ease-out;
}

@keyframes pulse {
  0% {
    transform: scale(1);
    opacity: 1;
  }
  50% {
    transform: scale(1.3);
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

@media (max-width: 640px) {
  .layout {
    border-radius: 0;
    min-height: 100vh;
  }

  .header,
  .footer {
    flex-direction: column;
    align-items: flex-start;
    gap: 12px;
  }

  .controls button {
    width: 100%;
  }
}
</file>

<file path=".worktrees/quota-page/app/transmissions/page.tsx">
"use client";

import { useEffect, useState, useRef, useCallback } from "react";
import Navigation from "@/components/Navigation";
import styles from "./page.module.css";
import { logEmitter } from "@/lib/api-logger-client";

interface Message {
  time: string;
  author: string;
  text: string;
}

interface OverlayMessage {
  id: string;
  author: string;
  message: string;
  timestamp: number;
}

export default function TransmissionsPage() {
  const [liveChatId, setLiveChatId] = useState<string | null>(null);
  const [videoId, setVideoId] = useState<string | null>(null);
  const [streamTitle, setStreamTitle] = useState("");
  const [streamStatus, setStreamStatus] = useState("Поиск трансляции...");
  const [pollingStatus, setPollingStatus] = useState("Ожидание...");
  const [messages, setMessages] = useState<Message[]>([]);
  const [isError, setIsError] = useState(false);
  const [pollingError, setPollingError] = useState(false);
  const [isMonitoringEnabled, setIsMonitoringEnabled] = useState(() => {
    if (typeof window !== "undefined") {
      const saved = localStorage.getItem("monitoringEnabled");
      return saved !== null ? saved === "true" : true;
    }
    return true;
  });
  const [apiActivity, setApiActivity] = useState(false);
  const [errorDetails, setErrorDetails] = useState<string | null>(null);
  const [overlayMessage, setOverlayMessage] = useState<OverlayMessage | null>(null);
  const [activeMessageIndex, setActiveMessageIndex] = useState<number | null>(null);

  const eventSourceRef = useRef<EventSource | null>(null);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const checkStreamTimerRef = useRef<NodeJS.Timeout | null>(null);
  const retryDelayRef = useRef<number>(5000);
  const isMountedRef = useRef<boolean>(true);
  const abortControllerRef = useRef<AbortController | null>(null);
  const checkForStreamRef = useRef<(() => Promise<void>) | null>(null);

  useEffect(() => {
    if (typeof window !== "undefined") {
      localStorage.setItem("monitoringEnabled", String(isMonitoringEnabled));
    }
  }, [isMonitoringEnabled]);

  // Listen for API activity
  useEffect(() => {
    const handleApiLog = () => {
      setApiActivity(true);
      setTimeout(() => setApiActivity(false), 1000);
    };

    logEmitter.on("newLog", handleApiLog);
    return () => {
      logEmitter.off("newLog", handleApiLog);
    };
  }, []);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const stopStreaming = useCallback(() => {
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
      eventSourceRef.current = null;
    }
    setLiveChatId(null);
    setVideoId(null);
    setStreamTitle("");
    setMessages([]);
  }, []);

  const startStreaming = useCallback(
    (payload: { liveChatId: string; videoId: string; title?: string }) => {
      if (!isMountedRef.current || !isMonitoringEnabled || document.hidden) {
        return;
      }

      const chatId = payload.liveChatId;
      const vidId = payload.videoId;

      setLiveChatId(chatId);
      setVideoId(vidId);
      setStreamTitle(payload.title ?? "");
      setStreamStatus("Чат подключен");
      setPollingStatus("Получение сообщений...");
      setPollingError(false);
      setIsError(false);
      setErrorDetails(null);

      if (chatId && vidId) {
        const url = `/api/messages/stream?liveChatId=${encodeURIComponent(chatId)}&videoId=${encodeURIComponent(vidId)}`;
        const eventSource = new EventSource(url);
        eventSourceRef.current = eventSource;

        eventSource.onmessage = (event) => {
          if (!isMountedRef.current) return;
          try {
            const data = JSON.parse(event.data);
            if (data.messages && Array.isArray(data.messages)) {
              setMessages((prev) => [...prev, ...data.messages]);
              setPollingStatus(
                "Последнее обновление: " +
                  new Date().toLocaleTimeString("ru-RU", { hour12: false })
              );
              setPollingError(false);
              setErrorDetails(null);
            }
            if (data.error) {
              setPollingStatus("Ошибка получения сообщений");
              setPollingError(true);
              setErrorDetails(data.error);
            }
          } catch (error) {
            console.error("Failed to parse SSE message:", error);
          }
        };

        eventSource.onerror = () => {
          if (!isMountedRef.current) return;
          setPollingStatus("Ошибка подключения");
          setPollingError(true);
          eventSource.close();
          eventSourceRef.current = null;

          if (isMonitoringEnabled && !document.hidden && isMountedRef.current && checkForStreamRef.current) {
            checkStreamTimerRef.current = setTimeout(() => {
              checkForStreamRef.current?.();
            }, 5000);
          }
        };
      }
    },
    [isMonitoringEnabled]
  );

  const scheduleNextCheck = useCallback(() => {
    if (checkStreamTimerRef.current) {
      clearTimeout(checkStreamTimerRef.current);
      checkStreamTimerRef.current = null;
    }

    if (
      isMonitoringEnabled &&
      !document.hidden &&
      isMountedRef.current &&
      !eventSourceRef.current &&
      checkForStreamRef.current
    ) {
      checkStreamTimerRef.current = setTimeout(() => {
        checkForStreamRef.current?.();
      }, retryDelayRef.current);
    }
  }, [isMonitoringEnabled]);

  const checkForStream = useCallback(async () => {
    if (!isMonitoringEnabled || document.hidden || !isMountedRef.current) {
      return;
    }

    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    abortControllerRef.current = new AbortController();

    try {
      setStreamStatus("Поиск трансляции...");
      setPollingStatus("Проверка...");
      setIsError(false);
      setErrorDetails(null);

      const response = await fetch("/api/live-chat-id", {
        signal: abortControllerRef.current.signal,
      });

      const payload = await response.json();

      if (!response.ok) {
        throw new Error(payload.error || "live chat id not found");
      }

      retryDelayRef.current = 5000;
      startStreaming(payload);
    } catch (error: any) {
      if (error.name === "AbortError") {
        return;
      }

      if (!isMountedRef.current) return;

      const errorMessage = error.message || "Неизвестная ошибка";
      setStreamStatus("Нет активной трансляции");
      setPollingStatus("Ожидание трансляции");
      setIsError(true);
      setPollingError(true);
      setErrorDetails(errorMessage);

      retryDelayRef.current = Math.min(retryDelayRef.current * 2, 30000);
      scheduleNextCheck();
    }
  }, [isMonitoringEnabled, startStreaming, scheduleNextCheck]);

  useEffect(() => {
    checkForStreamRef.current = checkForStream;
  }, [checkForStream]);

  const showInOverlay = useCallback(async (message: Message, index: number) => {
    try {
      const response = await fetch("/api/overlay", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          id: `${index}-${Date.now()}`,
          author: message.author,
          message: message.text,
        }),
      });
      if (response.ok) {
        const data = await response.json();
        setOverlayMessage(data.overlay);
        setActiveMessageIndex(index);
      }
    } catch (error) {
      console.error("Failed to show in overlay:", error);
    }
  }, []);

  const clearOverlay = useCallback(async () => {
    try {
      const response = await fetch("/api/overlay", { method: "DELETE" });
      if (response.ok) {
        setOverlayMessage(null);
        setActiveMessageIndex(null);
      }
    } catch (error) {
      console.error("Failed to clear overlay:", error);
    }
  }, []);

  const toggleMonitoring = useCallback(() => {
    const newValue = !isMonitoringEnabled;
    setIsMonitoringEnabled(newValue);

    if (!newValue) {
      stopStreaming();
      if (checkStreamTimerRef.current) {
        clearTimeout(checkStreamTimerRef.current);
        checkStreamTimerRef.current = null;
      }
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
        abortControllerRef.current = null;
      }
      setStreamStatus("Мониторинг выключен");
      setPollingStatus("Ожидание...");
    } else {
      retryDelayRef.current = 5000;
      if (checkForStreamRef.current) {
        checkForStreamRef.current();
      }
    }
  }, [isMonitoringEnabled, stopStreaming]);

  useEffect(() => {
    isMountedRef.current = true;

    if (isMonitoringEnabled && checkForStreamRef.current) {
      checkForStreamRef.current();
    }

    return () => {
      isMountedRef.current = false;
      if (eventSourceRef.current) {
        eventSourceRef.current.close();
        eventSourceRef.current = null;
      }
      if (checkStreamTimerRef.current) {
        clearTimeout(checkStreamTimerRef.current);
        checkStreamTimerRef.current = null;
      }
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
        abortControllerRef.current = null;
      }
    };
  }, [isMonitoringEnabled]);

  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.hidden) {
        if (eventSourceRef.current) {
          eventSourceRef.current.close();
          eventSourceRef.current = null;
        }
        if (checkStreamTimerRef.current) {
          clearTimeout(checkStreamTimerRef.current);
          checkStreamTimerRef.current = null;
        }
        if (abortControllerRef.current) {
          abortControllerRef.current.abort();
          abortControllerRef.current = null;
        }
      } else if (isMonitoringEnabled && isMountedRef.current && checkForStreamRef.current) {
        retryDelayRef.current = 5000;
        checkForStreamRef.current();
      }
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);
    return () => {
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, [isMonitoringEnabled, checkForStream]);

  return (
    <div className={styles.layout}>
      <Navigation />
      <header className={styles.header}>
        <div className={styles.streamInfo}>
          <span className={`${styles.streamStatus} ${isError ? styles.statusError : ""}`}>
            {streamStatus}
          </span>
          <h1 className={styles.streamTitle}>{streamTitle}</h1>
        </div>
        <div className={styles.controls}>
          <button
            onClick={toggleMonitoring}
            type="button"
            className={isMonitoringEnabled ? styles.monitoringActive : styles.monitoringInactive}
          >
            {isMonitoringEnabled ? "Выключить мониторинг" : "Включить мониторинг"}
          </button>
          <button onClick={() => checkForStreamRef.current?.()} type="button">
            Обновить
          </button>
        </div>
      </header>
      <div className={styles.overlayPanel}>
        <div className={styles.overlayStatus}>
          {overlayMessage ? (
            <>
              <span className={styles.overlayActive}>В оверлее:</span>
              <span className={styles.overlayAuthor}>{overlayMessage.author}</span>
            </>
          ) : (
            <span className={styles.overlayEmpty}>Оверлей пуст</span>
          )}
        </div>
        {overlayMessage && (
          <button onClick={clearOverlay} className={styles.clearOverlayBtn} type="button">
            Убрать из оверлея
          </button>
        )}
      </div>
      <main className={styles.content}>
        <ul className={styles.messages}>
          {messages.map((message, index) => (
            <li key={index} className={`${styles.message} ${activeMessageIndex === index ? styles.messageActive : ""}`}>
              <time>{message.time}</time>
              <strong>{message.author}</strong>
              <button
                onClick={() => showInOverlay(message, index)}
                className={styles.overlayBtn}
                type="button"
                title="Показать в оверлее"
              >
                📺
              </button>
              <p>{message.text}</p>
            </li>
          ))}
          <div ref={messagesEndRef} />
        </ul>
      </main>
      <footer className={styles.footer}>
        <div className={styles.footerStatus}>
          <span className={pollingError ? styles.statusError : ""}>{pollingStatus}</span>
          {errorDetails && (
            <span className={styles.errorDetails}>{errorDetails}</span>
          )}
        </div>
        <span className={styles.apiIndicator}>
          <span className={`${styles.apiDot} ${apiActivity ? styles.apiActive : ""}`} />
          API
        </span>
      </footer>
    </div>
  );
}
</file>

<file path=".worktrees/quota-page/app/videos/page.module.css">
.layout {
  width: 100%;
  min-height: 100vh;
  display: grid;
  grid-template-rows: auto 1fr;
  background: rgba(15, 23, 42, 0.85);
}

.content {
  padding: 32px 24px;
  width: 100%;
  max-width: 100%;
}

.title {
  font-size: 28px;
  font-weight: 600;
  margin-bottom: 32px;
  color: var(--text);
}

.actions {
  display: flex;
  justify-content: flex-start;
  margin-bottom: 24px;
}

.loadButton {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 12px 20px;
  border-radius: 8px;
  border: none;
  background: var(--accent);
  color: #0f172a;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: transform 0.15s ease, box-shadow 0.15s ease, opacity 0.15s ease;
}

.loadButton:hover {
  transform: translateY(-1px);
  box-shadow: 0 12px 24px rgba(56, 189, 248, 0.35);
}

.loadButton:active {
  transform: translateY(0);
  box-shadow: none;
}

.loadButton:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

.loading,
.error,
.empty {
  padding: 24px;
  text-align: center;
  color: var(--text-muted);
}

.error {
  color: var(--error);
}

.grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
  gap: 24px;
  width: 100%;
}

.videoCard {
  background: rgba(30, 41, 59, 0.85);
  border-radius: 12px;
  border: 1px solid rgba(56, 189, 248, 0.1);
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.thumbnailContainer {
  width: 100%;
  aspect-ratio: 16 / 9;
  overflow: hidden;
  background: rgba(0, 0, 0, 0.3);
}

.thumbnail {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.videoInfo {
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  flex: 1;
}

.videoTitle {
  font-size: 18px;
  font-weight: 600;
  color: var(--text);
  margin: 0;
  line-height: 1.4;
}

.videoMeta {
  display: flex;
  align-items: center;
  gap: 12px;
}

.publishedDate {
  font-size: 14px;
  color: var(--text-muted);
}

.descriptionContainer {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-top: 8px;
}

.descriptionLabel {
  font-size: 14px;
  font-weight: 500;
  color: var(--text-muted);
}

.descriptionInput {
  width: 100%;
  padding: 12px;
  background: rgba(15, 23, 42, 0.6);
  border: 1px solid rgba(148, 163, 184, 0.2);
  border-radius: 8px;
  color: var(--text);
  font-size: 14px;
  font-family: inherit;
  line-height: 1.5;
  resize: vertical;
  min-height: 120px;
  transition: border-color 0.2s ease;
}

.descriptionInput:focus {
  outline: none;
  border-color: var(--accent);
}

.descriptionInput::placeholder {
  color: var(--text-muted);
}

@media (max-width: 1024px) {
  .grid {
    grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
  }
}

@media (max-width: 768px) {
  .content {
    padding: 24px 16px;
  }

  .grid {
    grid-template-columns: 1fr;
    gap: 20px;
  }
}

@media (max-width: 480px) {
  .content {
    padding: 20px 12px;
  }

  .title {
    font-size: 24px;
    margin-bottom: 24px;
  }

  .videoInfo {
    padding: 16px;
  }

  .videoTitle {
    font-size: 16px;
  }
}
</file>

<file path=".worktrees/quota-page/app/videos/page.tsx">
"use client";

import { useState } from "react";
import Navigation from "@/components/Navigation";
import styles from "./page.module.css";

interface Video {
  id: string;
  title: string;
  description: string;
  publishedAt: string;
  thumbnail: string;
  channelId: string;
  channelTitle: string;
}

export default function VideosPage() {
  const [videos, setVideos] = useState<Video[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [descriptions, setDescriptions] = useState<Record<string, string>>({});
  const [hasLoaded, setHasLoaded] = useState(false);

  const fetchVideos = async () => {
    if (loading) {
      return;
    }

    try {
      setLoading(true);
      const response = await fetch("/api/videos");
      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || "Не удалось загрузить видео");
      }

      setVideos(data.videos || []);

      const initialDescriptions: Record<string, string> = {};
      data.videos?.forEach((video: Video) => {
        initialDescriptions[video.id] = video.description || "";
      });
      setDescriptions(initialDescriptions);

      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Неизвестная ошибка");
    } finally {
      setLoading(false);
      setHasLoaded(true);
    }
  };

  const handleDescriptionChange = (videoId: string, value: string) => {
    setDescriptions((prev) => ({
      ...prev,
      [videoId]: value,
    }));
  };

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleDateString("ru-RU", {
      year: "numeric",
      month: "long",
      day: "numeric",
    });
  };

  return (
    <div className={styles.layout}>
      <Navigation />
      <main className={styles.content}>
        <h1 className={styles.title}>Видео</h1>

        <div className={styles.actions}>
          <button
            className={styles.loadButton}
            onClick={fetchVideos}
            disabled={loading}
          >
            {loading ? "Загрузка..." : hasLoaded ? "Обновить список" : "Загрузить видео"}
          </button>
        </div>
        
        {error && <div className={styles.error}>{error}</div>}

        {!loading && hasLoaded && !error && videos.length === 0 && (
          <div className={styles.empty}>Видео не найдены</div>
        )}
        
        {!loading && !error && videos.length > 0 && (
          <div className={styles.grid}>
            {videos.map((video) => (
              <div key={video.id} className={styles.videoCard}>
                <div className={styles.thumbnailContainer}>
                  <img
                    src={video.thumbnail}
                    alt={video.title}
                    className={styles.thumbnail}
                  />
                </div>
                <div className={styles.videoInfo}>
                  <h3 className={styles.videoTitle}>{video.title}</h3>
                  <div className={styles.videoMeta}>
                    <span className={styles.publishedDate}>
                      {formatDate(video.publishedAt)}
                    </span>
                  </div>
                  <div className={styles.descriptionContainer}>
                    <label className={styles.descriptionLabel}>
                      Описание:
                    </label>
                    <textarea
                      className={styles.descriptionInput}
                      value={descriptions[video.id] || ""}
                      onChange={(e) =>
                        handleDescriptionChange(video.id, e.target.value)
                      }
                      placeholder="Введите описание видео..."
                      rows={6}
                    />
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
      </main>
    </div>
  );
}
</file>

<file path=".worktrees/quota-page/app/globals.css">
:root {
  color-scheme: dark light;
  --bg: #0f172a;
  --panel: #1e293b;
  --accent: #38bdf8;
  --text: #e2e8f0;
  --text-muted: #94a3b8;
  --error: #f87171;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
}
</file>

<file path=".worktrees/quota-page/app/layout.tsx">
import type { Metadata } from "next";
import "./globals.css";
import Navigation from "@/components/Navigation";

export const metadata: Metadata = {
  title: "YouTube Live Chat",
  description: "Помощник по YouTube каналу",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="ru">
      <body>{children}</body>
    </html>
  );
}
</file>

<file path=".worktrees/quota-page/app/page.tsx">
import { redirect } from "next/navigation";

export default function HomePage() {
  redirect("/transmissions");
}
</file>

<file path=".worktrees/quota-page/components/Navigation.module.css">
.nav {
  display: flex;
  gap: 8px;
  padding: 16px 24px;
  background: rgba(30, 41, 59, 0.8);
  border-bottom: 1px solid rgba(148, 163, 184, 0.2);
}

.link {
  padding: 8px 16px;
  color: var(--text-muted);
  text-decoration: none;
  border-radius: 8px;
  transition: all 0.2s ease;
  font-weight: 500;
}

.link:hover {
  background: rgba(56, 189, 248, 0.1);
  color: var(--accent);
}

.link.active {
  background: var(--accent);
  color: #0b1120;
}
</file>

<file path=".worktrees/quota-page/components/Navigation.tsx">
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import styles from "./Navigation.module.css";

export default function Navigation() {
  const pathname = usePathname();

  return (
    <nav className={styles.nav}>
      <Link
        href="/transmissions"
        className={`${styles.link} ${pathname === "/transmissions" ? styles.active : ""}`}
      >
        Трансляции
      </Link>
      <Link
        href="/overview"
        className={`${styles.link} ${pathname === "/overview" ? styles.active : ""}`}
      >
        Обзор
      </Link>
      <Link
        href="/videos"
        className={`${styles.link} ${pathname === "/videos" ? styles.active : ""}`}
      >
        Видео
      </Link>
      <Link
        href="/quota"
        className={`${styles.link} ${pathname === "/quota" ? styles.active : ""}`}
      >
        Квота
      </Link>
    </nav>
  );
}
</file>

<file path=".worktrees/quota-page/docs/plans/2025-12-07-overlay-moderation-design.md">
# Overlay Moderation Feature Design

## Overview

Фича для показа выбранных комментариев из чата в OBS оверлее во время стрима. Стример выбирает комментарий в админке, он появляется в оверлее с typewriter анимацией, зрители видят на какой вопрос отвечает стример.

## User Flow

1. Стример открывает `/transmissions` и `/obs` (в OBS Browser Source)
2. Во время стрима видит интересный комментарий в чате
3. Нажимает кнопку "показать в оверлее" рядом с комментарием
4. Комментарий появляется в OBS с typewriter анимацией
5. Стример отвечает голосом
6. Нажимает "убрать из оверлея"
7. Комментарий исчезает

## Architecture

### API Endpoint: `/api/overlay`

```typescript
// app/api/overlay/route.ts

interface OverlayMessage {
  id: string
  author: string
  authorPhoto?: string
  message: string
  timestamp: number
}

let currentOverlay: OverlayMessage | null = null

// GET — получить текущий комментарий
// POST — установить комментарий
// DELETE — очистить оверлей
```

### Data Flow

```
[/transmissions] --POST--> [/api/overlay] <--GET(polling)-- [/obs]
                 --DELETE->
```

Состояние хранится в памяти сервера (переменная модуля). Для локального использования этого достаточно.

## UI Changes

### /transmissions

**Кнопка выбора (на каждом сообщении):**
- Иконка "📺" справа от сообщения
- При клике: POST `/api/overlay` с данными сообщения
- Активный комментарий выделяется рамкой/цветом

**Панель управления оверлеем (вверху чата):**
- Индикатор статуса: "В оверлее: {автор}" или "Оверлей пуст"
- Кнопка "Убрать из оверлея" (DELETE `/api/overlay`)

### /obs

**Блок выбранного комментария:**
- Расположение: отдельный блок, не мешает основному чату
- Прозрачный когда пуст
- Polling: GET `/api/overlay` каждые 1.5 секунды

**Анимация появления:**
1. Fade-in контейнера (~0.3s)
2. Имя автора показывается сразу
3. Текст печатается посимвольно (~50ms на символ)

**Анимация исчезновения:**
- Fade-out (~0.3s)

**Стилизация:**
- Полупрозрачный фон
- Аватар автора (опционально)
- Имя автора выделено цветом
- Крупный читаемый текст

## Implementation Tasks

1. Создать `/api/overlay/route.ts` с GET/POST/DELETE
2. Добавить кнопку выбора к сообщениям в `/transmissions`
3. Добавить панель управления оверлеем в `/transmissions`
4. Создать компонент оверлея с typewriter анимацией
5. Интегрировать оверлей в `/obs` с polling

## Technical Notes

- Polling интервал 1.5s — баланс между отзывчивостью и нагрузкой
- Typewriter скорость ~50ms/символ — читаемо, но не слишком медленно
- Состояние в памяти сбрасывается при перезапуске сервера (приемлемо для MVP)
</file>

<file path=".worktrees/quota-page/docs/plans/2025-12-23-quota-page-design.md">
# Quota Page Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Создать страницу `/quota` для мониторинга расхода квоты YouTube API

**Architecture:** API endpoint читает из `api_request_logs` (PostgreSQL), фильтрует по Pacific Time, группирует по endpoint. React страница отображает счётчик и таблицу.

**Tech Stack:** Next.js 14 (App Router), PostgreSQL, CSS Modules

---

## Task 1: API Endpoint

**Files:**
- Create: `app/api/quota/route.ts`

**Step 1: Create API route file**

```typescript
// app/api/quota/route.ts
import { NextResponse } from "next/server";
import { Pool } from "pg";

const pool = new Pool({
  host: process.env.DB_HOST || "localhost",
  port: Number(process.env.DB_PORT || 5432),
  database: process.env.DB_NAME || "yt_chat",
  user: process.env.DB_USER || "postgres",
  password: process.env.DB_PASSWORD || "",
});

const DAILY_LIMIT = 10000;

export async function GET() {
  const client = await pool.connect();
  try {
    const todayStats = await client.query(`
      SELECT COALESCE(SUM(quota_cost), 0) as total_used
      FROM api_request_logs
      WHERE timestamp >= (NOW() AT TIME ZONE 'America/Los_Angeles')::date
                         AT TIME ZONE 'America/Los_Angeles'
    `);

    const byEndpoint = await client.query(`
      SELECT
        endpoint_type,
        COUNT(*)::int as count,
        SUM(quota_cost)::int as total_cost
      FROM api_request_logs
      WHERE timestamp >= (NOW() AT TIME ZONE 'America/Los_Angeles')::date
                         AT TIME ZONE 'America/Los_Angeles'
      GROUP BY endpoint_type
      ORDER BY total_cost DESC
    `);

    const used = Number(todayStats.rows[0].total_used);

    return NextResponse.json({
      today: {
        used,
        limit: DAILY_LIMIT,
      },
      byEndpoint: byEndpoint.rows.map((row) => ({
        endpoint: row.endpoint_type,
        count: row.count,
        cost: row.total_cost,
      })),
    });
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    return NextResponse.json({ error: message }, { status: 500 });
  } finally {
    client.release();
  }
}
```

**Step 2: Verify API works**

Run: `curl http://localhost:3000/api/quota`

Expected: JSON response with `today` and `byEndpoint` fields

**Step 3: Commit**

```bash
git add app/api/quota/route.ts
git commit -m "feat: add /api/quota endpoint for quota monitoring"
```

---

## Task 2: Page Styles

**Files:**
- Create: `app/quota/page.module.css`

**Step 1: Create styles file**

```css
/* app/quota/page.module.css */
.layout {
  width: min(960px, 100%);
  min-height: 100vh;
  margin: 0 auto;
  display: grid;
  grid-template-rows: auto 1fr;
  background: rgba(15, 23, 42, 0.85);
  border-radius: 16px;
  border: 1px solid rgba(148, 163, 184, 0.2);
  overflow: hidden;
  backdrop-filter: blur(16px);
}

.content {
  padding: 32px 24px;
}

.title {
  font-size: 28px;
  font-weight: 600;
  margin-bottom: 32px;
  color: var(--text);
}

.loading,
.error,
.empty {
  padding: 24px;
  text-align: center;
  color: var(--text-muted);
}

.error {
  color: var(--error);
}

/* Counter section */
.counter {
  padding: 24px;
  background: rgba(30, 41, 59, 0.85);
  border-radius: 12px;
  border: 1px solid rgba(56, 189, 248, 0.1);
  margin-bottom: 32px;
}

.counterLabel {
  font-size: 14px;
  color: var(--text-muted);
  margin-bottom: 8px;
}

.counterValue {
  font-size: 32px;
  font-weight: 700;
  color: var(--accent);
  margin-bottom: 16px;
}

.counterValue span {
  font-size: 20px;
  font-weight: 400;
  color: var(--text-muted);
}

.progressBar {
  height: 8px;
  background: rgba(148, 163, 184, 0.2);
  border-radius: 4px;
  overflow: hidden;
}

.progressFill {
  height: 100%;
  background: var(--accent);
  transition: width 0.3s;
}

/* Endpoint table */
.section {
  margin-bottom: 24px;
}

.sectionTitle {
  font-size: 16px;
  font-weight: 500;
  color: var(--text-muted);
  margin-bottom: 16px;
}

.table {
  width: 100%;
  border-collapse: collapse;
}

.table th {
  text-align: left;
  padding: 12px 16px;
  font-size: 12px;
  font-weight: 500;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  border-bottom: 1px solid rgba(148, 163, 184, 0.2);
}

.table th:last-child {
  text-align: right;
}

.table td {
  padding: 12px 16px;
  border-bottom: 1px solid rgba(148, 163, 184, 0.1);
}

.table td:last-child {
  text-align: right;
  font-weight: 600;
}

.endpoint {
  font-family: "SF Mono", "Monaco", "Consolas", monospace;
  font-size: 14px;
  color: var(--text);
}

.count {
  color: var(--text-muted);
  font-size: 14px;
}

@media (max-width: 640px) {
  .layout {
    border-radius: 0;
  }

  .content {
    padding: 24px 16px;
  }
}
```

**Step 2: Commit**

```bash
git add app/quota/page.module.css
git commit -m "feat: add styles for quota page"
```

---

## Task 3: Page Component

**Files:**
- Create: `app/quota/page.tsx`

**Step 1: Create page component**

```tsx
// app/quota/page.tsx
"use client";

import { useEffect, useState } from "react";
import Navigation from "@/components/Navigation";
import styles from "./page.module.css";

interface QuotaStats {
  today: {
    used: number;
    limit: number;
  };
  byEndpoint: Array<{
    endpoint: string;
    count: number;
    cost: number;
  }>;
}

export default function QuotaPage() {
  const [stats, setStats] = useState<QuotaStats | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchStats = async () => {
      try {
        setLoading(true);
        const response = await fetch("/api/quota");
        if (!response.ok) {
          throw new Error("Не удалось загрузить статистику квоты");
        }
        const data = await response.json();
        setStats(data);
        setError(null);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Неизвестная ошибка");
      } finally {
        setLoading(false);
      }
    };

    fetchStats();
  }, []);

  const formatNumber = (num: number) => {
    return num.toLocaleString("ru-RU");
  };

  const getPercentage = () => {
    if (!stats) return 0;
    return Math.round((stats.today.used / stats.today.limit) * 100);
  };

  return (
    <div className={styles.layout}>
      <Navigation />
      <main className={styles.content}>
        <h1 className={styles.title}>Квота API</h1>

        {loading && <div className={styles.loading}>Загрузка...</div>}

        {error && <div className={styles.error}>{error}</div>}

        {stats && (
          <>
            <div className={styles.counter}>
              <div className={styles.counterLabel}>Использовано сегодня</div>
              <div className={styles.counterValue}>
                {formatNumber(stats.today.used)}{" "}
                <span>/ {formatNumber(stats.today.limit)} единиц</span>
              </div>
              <div className={styles.progressBar}>
                <div
                  className={styles.progressFill}
                  style={{ width: `${getPercentage()}%` }}
                />
              </div>
            </div>

            <div className={styles.section}>
              <h2 className={styles.sectionTitle}>Расход по операциям</h2>
              {stats.byEndpoint.length === 0 ? (
                <div className={styles.empty}>Нет данных за сегодня</div>
              ) : (
                <table className={styles.table}>
                  <thead>
                    <tr>
                      <th>Endpoint</th>
                      <th>Запросов</th>
                      <th>Стоимость</th>
                    </tr>
                  </thead>
                  <tbody>
                    {stats.byEndpoint.map((row) => (
                      <tr key={row.endpoint}>
                        <td className={styles.endpoint}>{row.endpoint}</td>
                        <td className={styles.count}>{row.count}</td>
                        <td>{formatNumber(row.cost)}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              )}
            </div>
          </>
        )}
      </main>
    </div>
  );
}
```

**Step 2: Verify page renders**

Open: `http://localhost:3000/quota`

Expected: Page with counter showing "0 / 10,000 единиц" and empty table (or data if logs exist)

**Step 3: Commit**

```bash
git add app/quota/page.tsx
git commit -m "feat: add quota monitoring page"
```

---

## Task 4: Navigation Link

**Files:**
- Modify: `components/Navigation.tsx:25-29`

**Step 1: Add link to navigation**

Add after the "Видео" link (line 29):

```tsx
      <Link
        href="/quota"
        className={`${styles.link} ${pathname === "/quota" ? styles.active : ""}`}
      >
        Квота
      </Link>
```

**Step 2: Verify navigation**

Open: `http://localhost:3000/quota`

Expected: "Квота" link visible in navigation, highlighted when on `/quota` page

**Step 3: Commit**

```bash
git add components/Navigation.tsx
git commit -m "feat: add quota link to navigation"
```

---

## Verification Checklist

- [ ] `curl http://localhost:3000/api/quota` returns valid JSON
- [ ] `/quota` page loads without errors
- [ ] Counter shows current usage
- [ ] Table shows breakdown by endpoint (or "Нет данных" if empty)
- [ ] Navigation link works and highlights correctly
- [ ] Styling matches other pages (dark theme, same fonts)
</file>

<file path=".worktrees/quota-page/docs/youtube-api-quota.md">
# YouTube Data API v3 Quota

## Лимиты

| Параметр | Значение |
|----------|----------|
| Дневной лимит по умолчанию | **10,000 единиц** |
| Сброс квоты | Полночь по Pacific Time (PT) |
| Привязка | К Google Cloud проекту (не к API ключу) |

Несколько API ключей в одном проекте делят общую квоту.

## Стоимость операций

| Метод | Стоимость | Используется в проекте |
|-------|-----------|------------------------|
| `search.list` | **100** | `getLiveBroadcasts`, `getChannelVideos` |
| `videos.list` | 1 | `getLiveChatId`, `getVideosDetails` |
| `channels.list` | 1 | `getChannelStats` |
| `liveChatMessages.list` | ~5* | `fetchMessages` (polling) |
| `videos.update` | 50 | - |
| `videos.insert` | 1,600 | - |

*Точная стоимость `liveChatMessages.list` не указана в документации. Оценка 5 единиц.

## Расчёт для типичных сценариев

### Проверка активной трансляции
- `search.list` (eventType=live) = **100 единиц**

### Polling чата (1 час стрима)
- Интервал 5 сек = 720 запросов/час
- `liveChatMessages.list` × 720 = **~3,600 единиц**

### Загрузка списка видео
- `search.list` = 100
- `videos.list` (детали) = 1
- Итого: **101 единица**

### Просмотр статистики канала
- `channels.list` = **1 единица**

## Проблемные места в проекте

1. **`search.list` для проверки трансляции** — 100 единиц каждый раз
   - При polling каждые 30 сек = 2,880 единиц/день только на проверку

2. **`search.list` для списка видео** — 100 единиц
   - Решено: кнопка ручной загрузки

## Оптимизация

### 1. Использовать `fields` параметр
```typescript
youtube.videos.list({
  part: ["snippet"],
  id: [videoId],
  fields: "items(id,snippet/title)" // только нужные поля
})
```

### 2. Batch запросы
```typescript
// Плохо: 5 запросов = 5 единиц
for (const id of videoIds) {
  await youtube.videos.list({ id: [id] })
}

// Хорошо: 1 запрос = 1 единица
await youtube.videos.list({ id: videoIds })
```

### 3. ETags для кэширования
Если ресурс не изменился, возвращается `304 Not Modified` без расхода квоты.

### 4. Заменить `search.list` на `playlistItems.list`
Для получения видео канала использовать uploads playlist:
```typescript
// Стоимость: 1 единица вместо 100
const uploadsPlaylistId = "UU" + channelId.slice(2)
youtube.playlistItems.list({
  playlistId: uploadsPlaylistId,
  part: ["snippet"],
  maxResults: 50
})
```

### 5. Увеличить интервал проверки трансляции
Вместо polling каждые 5 сек — проверять реже или по событию.

## Увеличение квоты

Можно запросить увеличение через [Google Cloud Console](https://console.cloud.google.com/apis/api/youtube.googleapis.com/quotas).

Требования:
- Описание use case
- Соответствие YouTube API Terms of Service
- Прохождение compliance audit (для больших квот)

## Источники

- [Quota Calculator](https://developers.google.com/youtube/v3/determine_quota_cost)
- [Quota and Compliance Audits](https://developers.google.com/youtube/v3/guides/quota_and_compliance_audits)
- [YouTube API Quota Guide 2025](https://getlate.dev/blog/youtube-api-limits-how-to-calculate-api-usage-cost-and-fix-exceeded-api-quota)
</file>

<file path=".worktrees/quota-page/lib/api-logger-client.ts">
import { EventEmitter } from "events";

// Event emitter for real-time activity indicator (client-side only)
export const logEmitter = new EventEmitter();
</file>

<file path=".worktrees/quota-page/lib/api-logger.ts">
import { Pool } from "pg";
import { logEmitter } from "./api-logger-client";

const pool = new Pool({
  host: process.env.DB_HOST || "localhost",
  port: Number(process.env.DB_PORT || 5432),
  database: process.env.DB_NAME || "yt_chat",
  user: process.env.DB_USER || "postgres",
  password: process.env.DB_PASSWORD || "",
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});

// Quota costs based on YouTube Data API v3 documentation
export const QUOTA_COSTS = {
  "search.list": 100,
  "videos.list": 1,
  "channels.list": 1,
  "liveChatMessages.list": 5,
} as const;

export interface ApiLogEntry {
  id?: number;
  timestamp: Date;
  endpointType: string;
  methodName: string;
  requestParams?: Record<string, any>;
  status: "success" | "error";
  errorMessage?: string;
  quotaCost: number;
  responseTimeMs: number;
}

// Event emitter is exported from api-logger-client.ts
export { logEmitter } from "./api-logger-client";

/**
 * Save a log entry to the database
 */
async function saveLogToDatabase(log: ApiLogEntry): Promise<void> {
  const client = await pool.connect();
  try {
    await client.query(
      `INSERT INTO api_request_logs 
        (timestamp, endpoint_type, method_name, request_params, status, error_message, quota_cost, response_time_ms)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
      [
        log.timestamp,
        log.endpointType,
        log.methodName,
        log.requestParams ? JSON.stringify(log.requestParams) : null,
        log.status,
        log.errorMessage || null,
        log.quotaCost,
        log.responseTimeMs,
      ]
    );
  } catch (error) {
    console.error("Failed to save API log to database:", error);
  } finally {
    client.release();
  }
}

/**
 * Log an API request
 */
export async function logApiRequest(
  methodName: string,
  endpointType: keyof typeof QUOTA_COSTS,
  requestParams: Record<string, any> | undefined,
  status: "success" | "error",
  responseTimeMs: number,
  errorMessage?: string
): Promise<void> {
  const log: ApiLogEntry = {
    timestamp: new Date(),
    methodName,
    endpointType,
    requestParams,
    status,
    errorMessage,
    quotaCost: QUOTA_COSTS[endpointType] || 0,
    responseTimeMs,
  };

  // Emit event for real-time activity indicator
  logEmitter.emit("newLog", log);

  // Save to database asynchronously (don't await to avoid blocking)
  saveLogToDatabase(log).catch((error) => {
    console.error("Error saving API log:", error);
  });
}
</file>

<file path=".worktrees/quota-page/lib/database.ts">
import { Pool } from "pg";

const pool = new Pool({
  host: process.env.DB_HOST || "localhost",
  port: Number(process.env.DB_PORT || 5432),
  database: process.env.DB_NAME || "yt_chat",
  user: process.env.DB_USER || "postgres",
  password: process.env.DB_PASSWORD || "",
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});

export async function initDatabase() {
  const client = await pool.connect();
  try {
    await client.query(`
      CREATE TABLE IF NOT EXISTS chat_messages (
        id SERIAL PRIMARY KEY,
        message_id VARCHAR(255) UNIQUE NOT NULL,
        video_id VARCHAR(255),
        live_chat_id VARCHAR(255),
        author_name VARCHAR(255) NOT NULL,
        message_text TEXT NOT NULL,
        published_at TIMESTAMP NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
      
      CREATE INDEX IF NOT EXISTS idx_message_id ON chat_messages(message_id);
      CREATE INDEX IF NOT EXISTS idx_video_id ON chat_messages(video_id);
      CREATE INDEX IF NOT EXISTS idx_published_at ON chat_messages(published_at DESC);
      
      CREATE TABLE IF NOT EXISTS api_request_logs (
        id SERIAL PRIMARY KEY,
        timestamp TIMESTAMPTZ DEFAULT NOW(),
        endpoint_type VARCHAR(100) NOT NULL,
        method_name VARCHAR(100) NOT NULL,
        request_params JSONB,
        status VARCHAR(20) NOT NULL,
        error_message TEXT,
        quota_cost INTEGER NOT NULL,
        response_time_ms INTEGER NOT NULL
      );
      
      CREATE INDEX IF NOT EXISTS idx_api_logs_timestamp ON api_request_logs(timestamp DESC);
      CREATE INDEX IF NOT EXISTS idx_api_logs_endpoint_type ON api_request_logs(endpoint_type);
      CREATE INDEX IF NOT EXISTS idx_api_logs_status ON api_request_logs(status);
    `);
  } finally {
    client.release();
  }
}

export interface ChatMessage {
  messageId: string;
  videoId?: string;
  liveChatId?: string;
  authorName: string;
  messageText: string;
  publishedAt: Date;
}

export async function saveMessage(message: ChatMessage): Promise<void> {
  const client = await pool.connect();
  try {
    await client.query(
      `INSERT INTO chat_messages (message_id, video_id, live_chat_id, author_name, message_text, published_at)
       VALUES ($1, $2, $3, $4, $5, $6)
       ON CONFLICT (message_id) DO NOTHING`,
      [
        message.messageId,
        message.videoId || null,
        message.liveChatId || null,
        message.authorName,
        message.messageText,
        message.publishedAt,
      ]
    );
  } finally {
    client.release();
  }
}

export async function saveMessages(messages: ChatMessage[]): Promise<void> {
  if (messages.length === 0) return;
  
  const client = await pool.connect();
  try {
    await client.query("BEGIN");
    for (const message of messages) {
      await client.query(
        `INSERT INTO chat_messages (message_id, video_id, live_chat_id, author_name, message_text, published_at)
         VALUES ($1, $2, $3, $4, $5, $6)
         ON CONFLICT (message_id) DO NOTHING`,
        [
          message.messageId,
          message.videoId || null,
          message.liveChatId || null,
          message.authorName,
          message.messageText,
          message.publishedAt,
        ]
      );
    }
    await client.query("COMMIT");
  } catch (error) {
    await client.query("ROLLBACK");
    throw error;
  } finally {
    client.release();
  }
}

export async function getMessages(
  limit: number = 100,
  offset: number = 0,
  videoId?: string
): Promise<ChatMessage[]> {
  const client = await pool.connect();
  try {
    let query = `
      SELECT message_id, video_id, live_chat_id, author_name, message_text, published_at
      FROM chat_messages
    `;
    const params: any[] = [];
    
    if (videoId) {
      query += ` WHERE video_id = $1`;
      params.push(videoId);
    }
    
    query += ` ORDER BY published_at DESC LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
    params.push(limit, offset);
    
    const result = await client.query(query, params);
    return result.rows.map((row) => ({
      messageId: row.message_id,
      videoId: row.video_id,
      liveChatId: row.live_chat_id,
      authorName: row.author_name,
      messageText: row.message_text,
      publishedAt: row.published_at,
    }));
  } finally {
    client.release();
  }
}

export async function closeDatabase(): Promise<void> {
  await pool.end();
}
</file>

<file path=".worktrees/quota-page/lib/db-init.ts">
import { initDatabase } from "@/lib/database";

let dbInitialized = false;

export async function ensureDatabaseInitialized() {
  if (!dbInitialized) {
    try {
      await initDatabase();
      dbInitialized = true;
    } catch (error) {
      console.error("Ошибка инициализации базы данных:", error);
    }
  }
}
</file>

<file path=".worktrees/quota-page/lib/youtube-api.ts">
import { google, youtube_v3 } from "googleapis";
import { logApiRequest } from "./api-logger";

export function createYoutubeClient(apiKey: string) {
  return google.youtube({ version: "v3", auth: apiKey });
}

export async function getLiveBroadcasts(youtube: youtube_v3.Youtube, channelId: string) {
  const startTime = Date.now();
  try {
    const response = await youtube.search.list({
      part: ["snippet"],
      channelId,
      type: ["video"],
      eventType: "live",
      maxResults: 10,
    } as any);
    const responseTime = Date.now() - startTime;
    await logApiRequest(
      "getLiveBroadcasts",
      "search.list",
      { channelId, eventType: "live", maxResults: 10 },
      "success",
      responseTime
    );
    return response.data?.items ?? [];
  } catch (error) {
    const responseTime = Date.now() - startTime;
    await logApiRequest(
      "getLiveBroadcasts",
      "search.list",
      { channelId, eventType: "live", maxResults: 10 },
      "error",
      responseTime,
      error instanceof Error ? error.message : "Unknown error"
    );
    throw error;
  }
}

export async function getLiveChatId(youtube: youtube_v3.Youtube, videoId: string) {
  const startTime = Date.now();
  try {
    const response = await youtube.videos.list({
      part: ["liveStreamingDetails"],
      id: [videoId],
    });
    const responseTime = Date.now() - startTime;
    await logApiRequest(
      "getLiveChatId",
      "videos.list",
      { videoId },
      "success",
      responseTime
    );
    return response.data.items?.[0]?.liveStreamingDetails?.activeLiveChatId ?? null;
  } catch (error) {
    const responseTime = Date.now() - startTime;
    await logApiRequest(
      "getLiveChatId",
      "videos.list",
      { videoId },
      "error",
      responseTime,
      error instanceof Error ? error.message : "Unknown error"
    );
    throw error;
  }
}

export async function fetchMessages(
  youtube: youtube_v3.Youtube,
  liveChatId: string,
  pageToken?: string
) {
  const startTime = Date.now();
  try {
    const response = await youtube.liveChatMessages.list({
      liveChatId,
      part: ["id", "snippet", "authorDetails"],
      pageToken,
    });
    const responseTime = Date.now() - startTime;
    await logApiRequest(
      "fetchMessages",
      "liveChatMessages.list",
      { liveChatId, hasPageToken: !!pageToken },
      "success",
      responseTime
    );
    return response.data;
  } catch (error) {
    const responseTime = Date.now() - startTime;
    await logApiRequest(
      "fetchMessages",
      "liveChatMessages.list",
      { liveChatId, hasPageToken: !!pageToken },
      "error",
      responseTime,
      error instanceof Error ? error.message : "Unknown error"
    );
    throw error;
  }
}

export function formatMessage(item: youtube_v3.Schema$LiveChatMessage) {
  const time = item.snippet?.publishedAt
    ? new Date(item.snippet.publishedAt).toLocaleTimeString("ru-RU", { hour12: false })
    : "";
  const author = item.authorDetails?.displayName ?? "Неизвестный автор";
  const text = item.snippet?.displayMessage ?? "";
  const messageId = item.id ?? "";
  const publishedAt = item.snippet?.publishedAt ? new Date(item.snippet.publishedAt) : new Date();
  return { time, author, text, messageId, publishedAt };
}

export async function getChannelStats(youtube: youtube_v3.Youtube, channelId: string) {
  const startTime = Date.now();
  try {
    const response = await youtube.channels.list({
      part: ["snippet", "statistics"],
      id: [channelId],
    });
    
    const responseTime = Date.now() - startTime;
    await logApiRequest(
      "getChannelStats",
      "channels.list",
      { channelId },
      "success",
      responseTime
    );
    
    const channel = response.data.items?.[0];
    if (!channel) {
      return null;
    }
    
    return {
      title: channel.snippet?.title ?? "",
      description: channel.snippet?.description ?? "",
      subscriberCount: channel.statistics?.subscriberCount ?? "0",
      videoCount: channel.statistics?.videoCount ?? "0",
      viewCount: channel.statistics?.viewCount ?? "0",
    };
  } catch (error) {
    const responseTime = Date.now() - startTime;
    await logApiRequest(
      "getChannelStats",
      "channels.list",
      { channelId },
      "error",
      responseTime,
      error instanceof Error ? error.message : "Unknown error"
    );
    throw error;
  }
}

export async function getChannelVideos(youtube: youtube_v3.Youtube, channelId: string, maxResults: number = 50) {
  const startTime = Date.now();
  try {
    const response = await youtube.search.list({
      part: ["snippet"],
      channelId,
      type: ["video"],
      order: "date",
      maxResults,
    } as any);
    const responseTime = Date.now() - startTime;
    await logApiRequest(
      "getChannelVideos",
      "search.list",
      { channelId, maxResults },
      "success",
      responseTime
    );
    return response.data?.items ?? [];
  } catch (error) {
    const responseTime = Date.now() - startTime;
    await logApiRequest(
      "getChannelVideos",
      "search.list",
      { channelId, maxResults },
      "error",
      responseTime,
      error instanceof Error ? error.message : "Unknown error"
    );
    throw error;
  }
}

export async function getVideosDetails(youtube: youtube_v3.Youtube, videoIds: string[]) {
  if (videoIds.length === 0) return [];
  
  const startTime = Date.now();
  try {
    const response = await youtube.videos.list({
      part: ["snippet"],
      id: videoIds,
    });
    const responseTime = Date.now() - startTime;
    await logApiRequest(
      "getVideosDetails",
      "videos.list",
      { videoCount: videoIds.length },
      "success",
      responseTime
    );
    return response.data?.items ?? [];
  } catch (error) {
    const responseTime = Date.now() - startTime;
    await logApiRequest(
      "getVideosDetails",
      "videos.list",
      { videoCount: videoIds.length },
      "error",
      responseTime,
      error instanceof Error ? error.message : "Unknown error"
    );
    throw error;
  }
}

export async function getChannelVideosWithDetails(youtube: youtube_v3.Youtube, channelId: string, maxResults: number = 50) {
  const searchResults = await getChannelVideos(youtube, channelId, maxResults);
  
  if (searchResults.length === 0) {
    return [];
  }
  
  const videoIds = searchResults
    .map((item) => item.id?.videoId)
    .filter((id): id is string => !!id);
  
  if (videoIds.length === 0) {
    return [];
  }
  
  const videosDetails = await getVideosDetails(youtube, videoIds);
  
  return videosDetails.map((video) => ({
    id: video.id ?? "",
    title: video.snippet?.title ?? "",
    description: video.snippet?.description ?? "",
    publishedAt: video.snippet?.publishedAt ?? "",
    thumbnail: video.snippet?.thumbnails?.high?.url ?? video.snippet?.thumbnails?.default?.url ?? "",
    channelId: video.snippet?.channelId ?? "",
    channelTitle: video.snippet?.channelTitle ?? "",
  }));
}
</file>

<file path=".worktrees/quota-page/src/utils/database.ts">
import { Pool } from "pg";
import dotenv from "dotenv";

dotenv.config();

const pool = new Pool({
  host: process.env.DB_HOST || "localhost",
  port: Number(process.env.DB_PORT || 5432),
  database: process.env.DB_NAME || "yt_chat",
  user: process.env.DB_USER || "postgres",
  password: process.env.DB_PASSWORD || "",
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});

export async function initDatabase() {
  const client = await pool.connect();
  try {
    await client.query(`
      CREATE TABLE IF NOT EXISTS chat_messages (
        id SERIAL PRIMARY KEY,
        message_id VARCHAR(255) UNIQUE NOT NULL,
        video_id VARCHAR(255),
        live_chat_id VARCHAR(255),
        author_name VARCHAR(255) NOT NULL,
        message_text TEXT NOT NULL,
        published_at TIMESTAMP NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
      
      CREATE INDEX IF NOT EXISTS idx_message_id ON chat_messages(message_id);
      CREATE INDEX IF NOT EXISTS idx_video_id ON chat_messages(video_id);
      CREATE INDEX IF NOT EXISTS idx_published_at ON chat_messages(published_at DESC);
    `);
  } finally {
    client.release();
  }
}

export interface ChatMessage {
  messageId: string;
  videoId?: string;
  liveChatId?: string;
  authorName: string;
  messageText: string;
  publishedAt: Date;
}

export async function saveMessage(message: ChatMessage): Promise<void> {
  const client = await pool.connect();
  try {
    await client.query(
      `INSERT INTO chat_messages (message_id, video_id, live_chat_id, author_name, message_text, published_at)
       VALUES ($1, $2, $3, $4, $5, $6)
       ON CONFLICT (message_id) DO NOTHING`,
      [
        message.messageId,
        message.videoId || null,
        message.liveChatId || null,
        message.authorName,
        message.messageText,
        message.publishedAt,
      ]
    );
  } finally {
    client.release();
  }
}

export async function saveMessages(messages: ChatMessage[]): Promise<void> {
  if (messages.length === 0) return;
  
  const client = await pool.connect();
  try {
    await client.query("BEGIN");
    for (const message of messages) {
      await client.query(
        `INSERT INTO chat_messages (message_id, video_id, live_chat_id, author_name, message_text, published_at)
         VALUES ($1, $2, $3, $4, $5, $6)
         ON CONFLICT (message_id) DO NOTHING`,
        [
          message.messageId,
          message.videoId || null,
          message.liveChatId || null,
          message.authorName,
          message.messageText,
          message.publishedAt,
        ]
      );
    }
    await client.query("COMMIT");
  } catch (error) {
    await client.query("ROLLBACK");
    throw error;
  } finally {
    client.release();
  }
}

export async function getMessages(
  limit: number = 100,
  offset: number = 0,
  videoId?: string
): Promise<ChatMessage[]> {
  const client = await pool.connect();
  try {
    let query = `
      SELECT message_id, video_id, live_chat_id, author_name, message_text, published_at
      FROM chat_messages
    `;
    const params: any[] = [];
    
    if (videoId) {
      query += ` WHERE video_id = $1`;
      params.push(videoId);
    }
    
    query += ` ORDER BY published_at DESC LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
    params.push(limit, offset);
    
    const result = await client.query(query, params);
    return result.rows.map((row) => ({
      messageId: row.message_id,
      videoId: row.video_id,
      liveChatId: row.live_chat_id,
      authorName: row.author_name,
      messageText: row.message_text,
      publishedAt: row.published_at,
    }));
  } finally {
    client.release();
  }
}

export async function closeDatabase(): Promise<void> {
  await pool.end();
}
</file>

<file path=".worktrees/quota-page/src/utils/youtube-api.ts">
import { google, youtube_v3 } from "googleapis";

export function createYoutubeClient(apiKey: string) {
  return google.youtube({ version: "v3", auth: apiKey });
}

export async function getLiveBroadcasts(youtube: youtube_v3.Youtube, channelId: string) {
  const response = await youtube.search.list({
    part: ["snippet"],
    channelId,
    type: ["video"],
    eventType: "live",
    maxResults: 10,
  } as any);
  return response.data?.items ?? [];
}

export async function getLiveChatId(youtube: youtube_v3.Youtube, videoId: string) {
  const response = await youtube.videos.list({
    part: ["liveStreamingDetails"],
    id: [videoId],
  });
  return response.data.items?.[0]?.liveStreamingDetails?.activeLiveChatId ?? null;
}

export async function fetchMessages(
  youtube: youtube_v3.Youtube,
  liveChatId: string,
  pageToken?: string
) {
  const response = await youtube.liveChatMessages.list({
    liveChatId,
    part: ["id", "snippet", "authorDetails"],
    pageToken,
  });
  return response.data;
}

export function formatMessage(item: youtube_v3.Schema$LiveChatMessage) {
  const time = item.snippet?.publishedAt
    ? new Date(item.snippet.publishedAt).toLocaleTimeString("ru-RU", { hour12: false })
    : "";
  const author = item.authorDetails?.displayName ?? "Неизвестный автор";
  const text = item.snippet?.displayMessage ?? "";
  const messageId = item.id ?? "";
  const publishedAt = item.snippet?.publishedAt ? new Date(item.snippet.publishedAt) : new Date();
  return { time, author, text, messageId, publishedAt };
}
</file>

<file path=".worktrees/quota-page/src/get-channel-data.ts">
import dotenv from "dotenv";
import { google } from "googleapis";

dotenv.config();

const apiKey = process.env.YOUTUBE_API_KEY;
const channelId = process.env.YOUTUBE_CHANNEL_ID;
const channelUsername = process.env.YOUTUBE_CHANNEL_USERNAME;
const channelHandle = process.env.YOUTUBE_CHANNEL_HANDLE;

if (!apiKey) {
  throw new Error("YOUTUBE_API_KEY отсутствует в окружении");
}

const youtube = google.youtube({ version: "v3", auth: apiKey });

async function getChannelIdByHandle(handle: string): Promise<string | null> {
  try {
    const cleanHandle = handle.startsWith("@") ? handle : `@${handle}`;
    const response = await youtube.channels.list({
      part: ["id"],
      forHandle: cleanHandle,
    } as any);
    return response.data.items?.[0]?.id || null;
  } catch (error) {
    return null;
  }
}

async function getChannelIdByUsername(username: string): Promise<string | null> {
  try {
    const response = await youtube.channels.list({
      part: ["id"],
      forUsername: username,
    });
    return response.data.items?.[0]?.id || null;
  } catch (error) {
    return null;
  }
}

async function getChannelData(channelId: string) {
  const response = await youtube.channels.list({
    part: ["snippet", "statistics", "contentDetails"],
    id: [channelId],
  });
  return response.data.items?.[0];
}

async function getChannelVideos(channelId: string, maxResults: number = 10) {
  const response = await youtube.search.list({
    part: ["snippet"],
    channelId: channelId,
    type: "video",
    order: "date",
    maxResults: maxResults,
  } as any);
  return response.data?.items || [];
}

async function getLiveBroadcasts(channelId: string) {
  const response = await youtube.search.list({
    part: ["snippet"],
    channelId: channelId,
    type: "video",
    eventType: "live",
    maxResults: 10,
  } as any);
  return response.data?.items || [];
}

async function getUpcomingBroadcasts(channelId: string) {
  const response = await youtube.search.list({
    part: ["snippet"],
    channelId: channelId,
    type: "video",
    eventType: "upcoming",
    maxResults: 10,
  } as any);
  return response.data?.items || [];
}

async function run() {
  try {
    console.log("Получение данных канала...\n");

    let targetChannelId: string | undefined = channelId;

    if (!targetChannelId && channelHandle) {
      console.log(`Поиск канала по handle: ${channelHandle}`);
      const foundId = await getChannelIdByHandle(channelHandle);
      if (!foundId) {
        throw new Error(`Не удалось найти канал с handle: ${channelHandle}`);
      }
      targetChannelId = foundId;
      console.log(`Найден channel ID: ${targetChannelId}\n`);
    }

    if (!targetChannelId && channelUsername) {
      console.log(`Поиск канала по username: ${channelUsername}`);
      const foundId = await getChannelIdByUsername(channelUsername);
      if (!foundId) {
        throw new Error(`Не удалось найти канал с username: ${channelUsername}`);
      }
      targetChannelId = foundId;
      console.log(`Найден channel ID: ${targetChannelId}\n`);
    }

    if (!targetChannelId) {
      throw new Error("Укажите YOUTUBE_CHANNEL_ID, YOUTUBE_CHANNEL_HANDLE или YOUTUBE_CHANNEL_USERNAME в .env файле");
    }

    console.log("=== Информация о канале ===");
    const channelData = await getChannelData(targetChannelId);
    if (channelData) {
      console.log("Название:", channelData.snippet?.title);
      console.log("Описание:", channelData.snippet?.description?.substring(0, 100) + "...");
      console.log("Подписчиков:", channelData.statistics?.subscriberCount);
      console.log("Всего видео:", channelData.statistics?.videoCount);
      console.log("Просмотров:", channelData.statistics?.viewCount);
      console.log("Дата создания:", channelData.snippet?.publishedAt);
      console.log("Ссылка:", `https://www.youtube.com/channel/${targetChannelId}`);
    }

    console.log("\n=== Последние видео ===");
    const videos = await getChannelVideos(targetChannelId, 5);
    if (videos.length > 0) {
      videos.forEach((video: any, index: number) => {
        console.log(`${index + 1}. ${video.snippet?.title}`);
        console.log(`   Опубликовано: ${video.snippet?.publishedAt}`);
        console.log(`   ID видео: ${video.id?.videoId}`);
        console.log();
      });
    } else {
      console.log("Видео не найдены");
    }

    console.log("=== Активные трансляции ===");
    const liveBroadcasts = await getLiveBroadcasts(targetChannelId);
    if (liveBroadcasts.length > 0) {
      liveBroadcasts.forEach((broadcast: any, index: number) => {
        console.log(`${index + 1}. ${broadcast.snippet?.title}`);
        console.log(`   ID видео: ${broadcast.id?.videoId}`);
        console.log(`   Начало: ${broadcast.snippet?.publishedAt}`);
        console.log();
      });
    } else {
      console.log("Активных трансляций нет");
    }

    console.log("=== Предстоящие трансляции ===");
    const upcomingBroadcasts = await getUpcomingBroadcasts(targetChannelId);
    if (upcomingBroadcasts.length > 0) {
      upcomingBroadcasts.forEach((broadcast: any, index: number) => {
        console.log(`${index + 1}. ${broadcast.snippet?.title}`);
        console.log(`   ID видео: ${broadcast.id?.videoId}`);
        console.log(`   Запланировано: ${broadcast.snippet?.publishedAt}`);
        console.log();
      });
    } else {
      console.log("Предстоящих трансляций нет");
    }

  } catch (error) {
    if (error instanceof Error) {
      console.error("❌ Ошибка:", error.message);
    } else {
      console.error("❌ Неизвестная ошибка:", error);
    }
    process.exit(1);
  }
}

run();
</file>

<file path=".worktrees/quota-page/src/index.ts">
import dotenv from "dotenv";
import { google } from "googleapis";

dotenv.config();

const apiKey = process.env.YOUTUBE_API_KEY;
const liveChatId = process.env.YOUTUBE_LIVE_CHAT_ID;

if (!apiKey) {
  throw new Error("YOUTUBE_API_KEY отсутствует в окружении");
}

if (!liveChatId) {
  throw new Error("YOUTUBE_LIVE_CHAT_ID отсутствует в окружении");
}

const youtube = google.youtube({ version: "v3", auth: apiKey });

async function sleep(ms: number) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function formatMessage(item: {
  snippet?: { publishedAt?: string | null; displayMessage?: string | null };
  authorDetails?: { displayName?: string | null };
}) {
  const time = item.snippet?.publishedAt
    ? new Date(item.snippet.publishedAt).toLocaleTimeString("ru-RU", { hour12: false })
    : "";
  const author = item.authorDetails?.displayName ?? "Неизвестный автор";
  const text = item.snippet?.displayMessage ?? "";
  return { time, author, text };
}

async function fetchMessages(pageToken?: string) {
  const response = await youtube.liveChatMessages.list({
    liveChatId,
    part: ["id", "snippet", "authorDetails"],
    pageToken,
  });
  return response.data;
}

async function run() {
  let pageToken: string | undefined;
  while (true) {
    const data = await fetchMessages(pageToken);
    const items = data.items ?? [];
    for (const item of items) {
      const formatted = formatMessage(item);
      const pieces = [formatted.time, formatted.author, formatted.text].filter(Boolean);
      if (pieces.length > 0) {
        console.log(pieces.join(" | "));
      }
    }
    pageToken = data.nextPageToken ?? pageToken;
    const delay = data.pollingIntervalMillis ?? 2000;
    await sleep(delay);
  }
}

run().catch((error) => {
  console.error(error instanceof Error ? error.message : error);
  process.exit(1);
});
</file>

<file path=".worktrees/quota-page/src/test-channel-serejaris.ts">
import dotenv from "dotenv";
import { youtube_v3 } from "googleapis";
import { createYoutubeClient, fetchMessages, formatMessage, getLiveBroadcasts, getLiveChatId } from "./utils/youtube-api";

dotenv.config();

const apiKey = process.env.YOUTUBE_API_KEY;

if (!apiKey) {
  throw new Error("YOUTUBE_API_KEY отсутствует в окружении");
}

const youtube = createYoutubeClient(apiKey);
const channelHandle = process.env.YOUTUBE_CHANNEL_HANDLE ?? "@serejaris";

async function getChannelIdByHandle(handle: string): Promise<string | null> {
  const cleanHandle = handle.startsWith("@") ? handle : `@${handle}`;
  try {
    const response = await youtube.channels.list({
      part: ["id"],
      forHandle: cleanHandle,
    } as youtube_v3.Params$Resource$Channels$List);
    return response.data.items?.[0]?.id || null;
  } catch (error) {
    if (error instanceof Error) {
      console.error(`Ошибка при поиске handle ${cleanHandle}:`, error.message);
    }
    return null;
  }
}

async function getChannelData(channelId: string) {
  const response = await youtube.channels.list({
    part: ["snippet", "statistics", "contentDetails"],
    id: [channelId],
  });
  return response.data.items?.[0];
}

async function getChannelVideos(channelId: string, maxResults: number = 10) {
  const response = await youtube.search.list({
    part: ["snippet"],
    channelId,
    type: ["video"],
    order: "date",
    maxResults,
  } as youtube_v3.Params$Resource$Search$List);
  return response.data?.items || [];
}

async function testChannel() {
  try {
    const safeApiKey = apiKey as string;
    console.log(`Тестирование канала ${channelHandle}...\n`);
    console.log(`API ключ: ${safeApiKey.substring(0, 10)}...\n`);

    const channelId = await getChannelIdByHandle(channelHandle);

    if (!channelId) {
      throw new Error(`Не удалось найти канал с handle: ${channelHandle}`);
    }

    console.log(`✅ Канал найден! Channel ID: ${channelId}\n`);

    console.log("=== Информация о канале ===");
    const channelData = await getChannelData(channelId);
    if (channelData) {
      console.log("Название:", channelData.snippet?.title);
      console.log("Описание:", channelData.snippet?.description?.substring(0, 100) + "...");
      console.log("Подписчиков:", channelData.statistics?.subscriberCount);
      console.log("Всего видео:", channelData.statistics?.videoCount);
      console.log("Просмотров:", channelData.statistics?.viewCount);
      console.log("Дата создания:", channelData.snippet?.publishedAt);
      console.log("Ссылка:", `https://www.youtube.com/channel/${channelId}`);
    }

    console.log("\n=== Последние видео ===");
    const videos = await getChannelVideos(channelId, 5);
    if (videos.length > 0) {
      videos.forEach((video: any, index: number) => {
        console.log(`${index + 1}. ${video.snippet?.title}`);
        console.log(`   Опубликовано: ${video.snippet?.publishedAt}`);
        console.log(`   ID видео: ${video.id?.videoId}`);
        console.log();
      });
    } else {
      console.log("Видео не найдены");
    }

    console.log("\n=== Поиск активной трансляции ===");
    const liveBroadcasts = await getLiveBroadcasts(youtube, channelId);
    if (liveBroadcasts.length === 0) {
      console.log("❌ Активных трансляций не найдено");
      console.log("\n✅ Тест завершен. API работает корректно, но трансляций нет.");
      return;
    }

    const firstLiveVideo = liveBroadcasts[0];
    const videoId = firstLiveVideo.id?.videoId;
    if (!videoId) {
      throw new Error("Не удалось получить ID видео трансляции");
    }

    console.log(`Найдена трансляция: ${firstLiveVideo.snippet?.title}`);
    console.log(`ID видео: ${videoId}`);

    console.log("\n=== Получение Live Chat ID ===");
    const chatId = await getLiveChatId(youtube, videoId);
    if (!chatId) {
      console.log("❌ Не удалось получить Live Chat ID");
      console.log("Возможно, трансляция не имеет активного чата или чат отключен");
      return;
    }

    console.log(`✅ Live Chat ID найден: ${chatId}`);

    console.log("\n=== Тестирование получения сообщений ===");
    const messagesData = await fetchMessages(youtube, chatId);
    const messages = messagesData.items || [];

    if (messages.length === 0) {
      console.log("Сообщений в чате пока нет");
    } else {
      console.log(`Найдено сообщений: ${messages.length}\n`);
      messages.forEach((item: any) => {
        const formatted = formatMessage(item);
        const pieces = [formatted.time, formatted.author, formatted.text].filter(Boolean);
        if (pieces.length > 0) {
          console.log(pieces.join(" | "));
        }
      });
    }

    console.log("\n✅ Тест успешно завершен! Live Chat ID извлечен и сообщения получены.");
  } catch (error) {
    if (error instanceof Error) {
      console.error("❌ Ошибка:", error.message);
    } else {
      console.error("❌ Неизвестная ошибка:", error);
    }
    process.exit(1);
  }
}

testChannel();
</file>

<file path=".worktrees/quota-page/src/test-connection.ts">
import dotenv from "dotenv";
import { google } from "googleapis";

dotenv.config();

const apiKey = process.env.YOUTUBE_API_KEY;

if (!apiKey) {
  throw new Error("YOUTUBE_API_KEY отсутствует в окружении");
}

const youtube = google.youtube({ version: "v3", auth: apiKey });

async function testConnection() {
  try {
    console.log("Проверка подключения к YouTube API...");
    console.log("API ключ:", apiKey!.substring(0, 10) + "...");
    
    const response = await youtube.videos.list({
      part: ["snippet"],
      chart: "mostPopular",
      maxResults: 1,
      regionCode: "RU",
    });

    if (response.data.items && response.data.items.length > 0) {
      const video = response.data.items[0];
      console.log("✅ Подключение успешно!");
      console.log("Тестовое видео:", video.snippet?.title);
      console.log("Канал:", video.snippet?.channelTitle);
      console.log("API работает корректно.");
    } else {
      console.log("⚠️ Подключение установлено, но данные не получены.");
    }
  } catch (error) {
    if (error instanceof Error) {
      console.error("❌ Ошибка подключения:", error.message);
      if (error.message.includes("API key")) {
        console.error("Проверьте правильность API ключа.");
      }
    } else {
      console.error("❌ Неизвестная ошибка:", error);
    }
    process.exit(1);
  }
}

testConnection();
</file>

<file path=".worktrees/quota-page/.env.example">
YOUTUBE_API_KEY=YOUR_YOUTUBE_API_KEY
YOUTUBE_LIVE_CHAT_ID=YOUR_LIVE_CHAT_ID
YOUTUBE_CHANNEL_ID=YOUR_CHANNEL_ID
YOUTUBE_CHANNEL_USERNAME=YOUR_CHANNEL_USERNAME
YOUTUBE_CHANNEL_HANDLE=@serejaris

DB_HOST=localhost
DB_PORT=5432
DB_NAME=yt_chat
DB_USER=ris
DB_PASSWORD=
</file>

<file path=".worktrees/quota-page/.git">
gitdir: /Users/ris/Documents/GitHub/yt-chat/.git/worktrees/quota-page
</file>

<file path=".worktrees/quota-page/.gitignore">
# Зависимости
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Переменные окружения
.env
.env.local
.env.*.local

# Next.js
.next/
out/
next-env.d.ts

# Скомпилированные файлы
dist/
build/
*.js.map
*.d.ts

# IDE и редакторы
.vscode/
.idea/
*.swp
*.swo
*~
.DS_Store

# Логи
logs/
*.log

# Временные файлы
tmp/
temp/
*.tmp

# Кэш
.cache/
.parcel-cache/
.eslintcache

# Тестовое покрытие
coverage/
.nyc_output/
</file>

<file path=".worktrees/quota-page/CLAUDE.md">
# YT-Chat Project

YouTube канал помощник с live chat интеграцией и статистикой.

## Agents

Для фронтенд задач (компоненты, страницы, стили) используй агента `frontend-developer`.

## Stack

- Next.js 14 (App Router)
- PostgreSQL (pg)
- YouTube Data API v3 (googleapis)
- TypeScript

## Structure

```
app/                    # Next.js pages
  api/                  # API routes
    channel-stats/      # Статистика канала
    live-chat-id/       # Получение chat ID трансляции
    messages/           # Сообщения чата (polling, SSE, DB)
    videos/             # Список видео канала
  obs/                  # OBS Browser Source интерфейс
  overview/             # Статистика канала
  transmissions/        # Live chat трансляций
  videos/               # Редактирование видео
components/             # React компоненты
lib/                    # Утилиты
  database.ts           # PostgreSQL подключение и операции
  youtube-api.ts        # YouTube API wrapper
  api-logger.ts         # Логирование API запросов
src/                    # CLI скрипты (legacy)
```

## Environment Variables

```
YOUTUBE_API_KEY         # YouTube Data API v3 key
YOUTUBE_CHANNEL_ID      # ID канала
DB_HOST=localhost       # PostgreSQL host
DB_PORT=5432
DB_NAME=yt_chat
DB_USER=ris             # Роль PostgreSQL (не postgres!)
DB_PASSWORD=
```

## Commands

```bash
npm run dev             # Development server
npm run build           # Production build
npm run test:connection # Тест YouTube API
npm run test:serejaris  # Тест получения chat ID
```

## API Quota

YouTube API имеет дневной лимит квоты. `search.list` стоит 100 единиц — используй кнопку загрузки на /videos вместо автозапросов.

## Database

PostgreSQL с таблицами:
- `chat_messages` — сообщения из live chat
- `api_request_logs` — логи API запросов

Таблицы создаются автоматически при первом подключении (`lib/database.ts:initDatabase`).
</file>

<file path=".worktrees/quota-page/next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
}

module.exports = nextConfig
</file>

<file path=".worktrees/quota-page/package.json">
{
  "name": "yt-chat",
  "version": "1.0.0",
  "description": "YouTube Live Chat помощник с статистикой канала",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test:connection": "ts-node src/test-connection.ts",
    "get-channel": "ts-node src/get-channel-data.ts",
    "test:serejaris": "ts-node src/test-channel-serejaris.ts"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@types/pg": "^8.15.6",
    "googleapis": "^165.0.0",
    "next": "^14.2.0",
    "pg": "^8.16.3",
    "react": "^18.3.0",
    "react-dom": "^18.3.0"
  },
  "devDependencies": {
    "@types/node": "^24.10.0",
    "@types/react": "^18.3.0",
    "@types/react-dom": "^18.3.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.9.3"
  }
}
</file>

<file path=".worktrees/quota-page/plan.md">
# Лог работы

- ✅ 2025-11-09 14:52:00: Запрос «Я хочу получать данные из моего стрима на YouTube-чате. Помоги мне сделать для этого простое приложение. Все, что оно должно делать, оно должно получать данные из моего YouTube-стрима. Помоги мне, пожалуйста, это сделать. ключ youtube data и пиа и v3 у меня уже есть»; результат: инициализирован Node.js проект, добавлены зависимости и конфигурация, реализован скрипт чтения чата, подготовлена документация.

- ✅ 2025-11-09 14:54:09: Запрос «А протестируй пока без Live Chat ID, пожалуйста.что просто работает уже у нас подключение»; результат: создан тестовый скрипт `src/test-connection.ts` для проверки подключения к YouTube API, добавлен npm скрипт `test:connection`, успешно протестировано подключение - API ключ работает корректно.

- ✅ 2025-11-09 15:54:07: Запрос «Протестируй, пожалуйста, что все работает, что ты можешь получить данные моего канала через API И, пожалуйста, вынеси в env переменную API-ключ»; результат: добавлена поддержка handle в `src/get-channel-data.ts`, создан скрипт `src/test-channel-serejaris.ts`, обновлен `package.json`, расширен `.env.example`, запуск `npm run test:serejaris` подтвердил успешное получение данных канала @serejaris.

- ✅ 2025-11-09 15:53:46: Запрос «Протестируй, пожалуйста, для моего канала получение актуальных данных через YouTube API»; результат: успешно выполнен тест получения данных канала через скрипт `test-channel-serejaris.ts`, получены актуальные данные канала @serejaris: Channel ID UCH6k750mdcOXU6PYHSCOlrA, название "Сережа Рис", 1860 подписчиков, 51 видео, 91791 просмотров, получен список последних 5 видео с актуальными датами публикации, API работает корректно.

- ✅ 2025-11-09 16:00:33: Запрос «излвеки плз мой чат-ид трансляции и протестируй что ты видишь сообщения из него»; результат: расширен скрипт `src/test-channel-serejaris.ts` функциями `getLiveBroadcasts()`, `getLiveChatId()`, `formatMessage()`, `fetchMessages()`, успешно найдена активная трансляция "Вайбкодинг с Cursor" (Video ID: -Fx9QShj_5o), извлечен Live Chat ID: Cg0KCy1GeDlRU2hqXzVvKicKGFVDSDZrNzUwbWRjT1hONlBZSFNDT2xyQRILLUZ4OVFTaGpfNW8, успешно получено и отображено 46 сообщений из чата трансляции, тест подтвердил работоспособность получения сообщений из live chat.

- ✅ 2025-11-09 16:01:32: Запрос «Отлично, добавь, пожалуйста, это в документацию»; результат: обновлен `README.md` с подробным описанием функциональности извлечения Live Chat ID из трансляции, добавлены разделы о запуске скрипта `npm run test:serejaris`, описан процесс автоматического поиска активной трансляции и извлечения chat-id, добавлена информация о других доступных командах проекта.

- ✅ 2025-11-09 17:45:00: Запрос «Собери фронт-энд, страницу, которая будет отображать живой чат из моей трансляции. Поищи в интернете что есть хорошее для этой задачи и реализуй найденный план»; результат: проведено исследование решений YouTube Live Chat, добавлен Express сервер, вынесены утилиты YouTube API, создана веб-страница с polling обновлением чата, обновлена документация.

- ✅ 2025-11-09 16:22:49: Запрос «Добавь, пожалуйста, в ToDo. Во-первых, обновление чата, интерфейс для того, чтобы это поддерживалось в OBS. И интеграция в отправку в Postgre базу данных, которую потом я хочу интегрировать вместе с чатом вайб-кодеров»; результат: добавлены задачи в ToDo, реализовано улучшение обновления чата через SSE endpoint `/api/messages/stream`, создан интерфейс для OBS на странице `/obs` с оптимизированным дизайном для Browser Source, интегрирована PostgreSQL база данных с автоматическим созданием таблицы `chat_messages`, добавлено сохранение всех сообщений в БД при получении через API, создан endpoint `/api/messages/db` для получения сообщений из БД с поддержкой фильтрации по videoId, пагинации и лимитов, обновлены фронтенд и OBS интерфейс для передачи videoId, добавлены переменные окружения для подключения к PostgreSQL (DB_HOST, DB_PORT, DB_NAME, DB_USER, DB_PASSWORD).

- ✅ 2025-11-XX XX:XX:XX: Запрос «я хочу сделать это приложение помощником себе по моему ютуб каналу поэтому помимо того что там уже есть трансляции она должна жить в отдельной так сказать вкладке мне кажется проект будет актуально если его переделать на next.js мне нужна еще отдельная вкладка это обзор моего youtube да статистика по нему»; результат: выполнена миграция проекта на Next.js 14 с App Router, созданы две основные вкладки: "Трансляции" (`/transmissions`) с функционалом live chat и "Обзор" (`/overview`) со статистикой канала (подписчики, просмотры, количество видео), сохранен OBS интерфейс в отдельном роуте `/obs`, мигрированы все API endpoints в `app/api/`, утилиты перенесены в `lib/`, создана навигация между вкладками, обновлены зависимости в `package.json`, удалены старые файлы Express сервера и статические HTML/CSS/JS файлы.

- ✅ 2025-11-10 17:03:07: Запрос «Я заметил, что даже если чат не доступен, API-шка все равно стучится по В общем, приложение стучится по API-шке Нужно проверить, что если во-первых трансляция не включена, то туда не нужно стучаться Если она не открыта, на вкладке нужны Ну и соответственно тоже нужна какая-то кнопка быть, да? Чтобы я это включил»; результат: реализована оптимизация API запросов с использованием лучших практик: разделена логика проверки трансляции и polling сообщений, добавлен exponential backoff для проверки трансляции (5s → 10s → 20s → 30s максимум), реализовано управление таймерами через useRef для предотвращения утечек памяти, добавлена автоматическая остановка запросов при неактивной вкладке через Page Visibility API, добавлена кнопка управления мониторингом с сохранением состояния в localStorage, реализована условная логика перед каждым запросом (проверка isMonitoringEnabled и document.hidden), добавлена поддержка AbortController для отмены fetch запросов. Рефакторинг выполнен для `app/transmissions/page.tsx` и `app/obs/page.tsx`, добавлены стили для кнопки управления мониторингом в `app/transmissions/page.module.css`. Теперь приложение не делает запросы к API когда трансляция не активна, вкладка скрыта или мониторинг выключен пользователем.

- ✅ 2025-11-10 17:07:35: Запрос «Мне нужна возможность редактировать описание для видео. То есть ты должен отобразить последнее моё видео на вкладке видео. Нужна быть новая вкладка видео, и там должны быть в ряд сетка из моих последних видео. Интерфейс должен использовать всю ширину экрана. Описание уже должно быть открыто, то есть я могу, я хочу за раз иметь возможность править много где видео.»; результат: создана новая вкладка "Видео" (`/videos`) с сеткой последних видео канала, расширен `lib/youtube-api.ts` функциями `getChannelVideos()`, `getVideosDetails()` и `getChannelVideosWithDetails()` для получения видео с полными данными включая описания, создан API endpoint `/api/videos` для получения списка видео, реализована страница `app/videos/page.tsx` с адаптивной сеткой видео на всю ширину экрана, каждое видео отображается с миниатюрой, названием, датой публикации и редактируемым полем описания (открыто по умолчанию), добавлена возможность одновременного редактирования описаний нескольких видео, созданы стили `app/videos/page.module.css` с адаптивным дизайном для разных размеров экрана, обновлена навигация `components/Navigation.tsx` с добавлением ссылки на вкладку "Видео".
- ✅ 2025-11-10 17:56:44: Запрос «пожалкуйста проведи иследование потому что все работает в вкладках обзор , не работает только для получения видео. разбеоись в чем дело приложение запущеное на @Browser http://localhost:3000/videos»; результат: воспроизвел обращение к `/api/videos`, зафиксировал ответ 500 с сообщением о превышении квоты YouTube API, установил причину в использовании метода `search.list` (стоимость 100 квотных единиц) и последовательного вызова `videos.list`, что быстро исчерпывает дневную квоту и блокирует загрузку видео на вкладке.
- ✅ 2025-11-10 18:01:04: Запрос «Ну раз такая дорогая цена вызовов то тебе нужно нам нужно сделать все собрать в но по кнопку да вот эти дорогие вызовы уже чтобы не автоматически вызывались а вызывались по кнопке»; результат: обновлен `app/videos/page.tsx` — удален автоматический запрос при монтировании, добавлена кнопка ручной загрузки/обновления списка видео с состояниями `idle/loading`; в `app/videos/page.module.css` добавлены стили `.actions` и `.loadButton`; проверено, что без нажатия запросы не выполняются, а повторный запрос возвращает прежнее сообщение о превышении квоты.
</file>

<file path=".worktrees/quota-page/README.md">
# YouTube Live Chat Fetcher

## Установка

1. Установите зависимости:
   ```
   npm install
   ```
2. Создайте файл `.env` по образцу `.env.example` и заполните:
   - `YOUTUBE_API_KEY` - ключ YouTube Data API v3
   - `YOUTUBE_CHANNEL_ID` - ID вашего канала
   - `PORT` - порт для сервера (по умолчанию 3000)
   - `DB_HOST`, `DB_PORT`, `DB_NAME`, `DB_USER`, `DB_PASSWORD` - параметры подключения к PostgreSQL (опционально)

## Запуск

### Веб-интерфейс

Для отображения чата в браузере:

```
npm run dev
```

Сервер запускается на `http://localhost:3000`, автоматически ищет активную трансляцию канала и отображает сообщения чата в реальном времени.

### Интерфейс для OBS

Для использования чата в OBS Studio через Browser Source:

1. Откройте OBS Studio
2. Добавьте источник "Browser Source"
3. Укажите URL: `http://localhost:3000/obs`
4. Настройте размеры по необходимости

Интерфейс оптимизирован для отображения в OBS с прозрачным фоном и анимацией появления сообщений.

### Получение сообщений из Live Chat

Для получения сообщений из указанного Live Chat в консоль:

```
npm start
```

### Извлечение Live Chat ID из трансляции

Для автоматического поиска активной трансляции канала и извлечения Live Chat ID:

```
npm run test:serejaris
```

Скрипт выполняет следующие действия:
1. Находит канал по handle (по умолчанию `@serejaris`, можно изменить через переменную окружения `YOUTUBE_CHANNEL_HANDLE`)
2. Ищет активную трансляцию канала
3. Извлекает Live Chat ID из трансляции
4. Получает и отображает сообщения из чата трансляции

## Другие команды

- `npm run test:connection` - тестирование подключения к YouTube API
- `npm run get-channel` - получение данных канала

## API Endpoints

### `/api/live-chat-id`
Получение Live Chat ID активной трансляции канала.

### `/api/messages`
Получение сообщений из чата трансляции.
- `liveChatId` (обязательный) - ID чата трансляции
- `pageToken` (опциональный) - токен для пагинации
- `videoId` (опциональный) - ID видео для сохранения в БД

### `/api/messages/stream`
Server-Sent Events (SSE) поток для получения сообщений в реальном времени.
- `liveChatId` (обязательный) - ID чата трансляции
- `videoId` (опциональный) - ID видео для сохранения в БД

### `/api/messages/db`
Получение сообщений из базы данных PostgreSQL.
- `limit` (опциональный, по умолчанию 100) - количество сообщений
- `offset` (опциональный, по умолчанию 0) - смещение для пагинации
- `videoId` (опциональный) - фильтрация по ID видео

## База данных

Приложение автоматически создает таблицу `chat_messages` в PostgreSQL при первом запуске. Все сообщения из чата сохраняются в базу данных для последующей интеграции с другими системами (например, чатом вайб-кодеров).

Схема таблицы:
- `id` - уникальный идентификатор записи
- `message_id` - уникальный ID сообщения из YouTube
- `video_id` - ID видео трансляции
- `live_chat_id` - ID чата трансляции
- `author_name` - имя автора сообщения
- `message_text` - текст сообщения
- `published_at` - время публикации сообщения
- `created_at` - время создания записи в БД
</file>

<file path=".worktrees/quota-page/tsconfig.json">
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules", "src"]
}
</file>

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Skill(superpowers:brainstorming)"
    ],
    "deny": [],
    "ask": []
  }
}
</file>

<file path="app/api/messages/db/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getMessages } from "@/lib/database";
import { ensureDatabaseInitialized } from "@/lib/db-init";

export async function GET(request: NextRequest) {
  try {
    await ensureDatabaseInitialized();
    const searchParams = request.nextUrl.searchParams;
    const limit = Number(searchParams.get("limit") || 100);
    const offset = Number(searchParams.get("offset") || 0);
    const videoId = searchParams.get("videoId") || undefined;
    
    const messages = await getMessages(limit, offset, videoId);
    return NextResponse.json({
      messages: messages.map((msg) => ({
        author: msg.authorName,
        text: msg.messageText,
        time: new Date(msg.publishedAt).toLocaleTimeString("ru-RU", { hour12: false }),
        publishedAt: msg.publishedAt.toISOString(),
      })),
    });
  } catch (error) {
    const message = error instanceof Error ? error.message : "Неизвестная ошибка";
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
</file>

<file path="app/api/messages/stream/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createYoutubeClient, fetchMessages, formatMessage } from "@/lib/youtube-api";
import { saveMessages } from "@/lib/database";
import { ensureDatabaseInitialized } from "@/lib/db-init";

export async function GET(request: NextRequest) {
  const apiKey = process.env.YOUTUBE_API_KEY;
  
  if (!apiKey) {
    return NextResponse.json({ error: "YOUTUBE_API_KEY отсутствует в окружении" }, { status: 500 });
  }

  const searchParams = request.nextUrl.searchParams;
  const liveChatId = searchParams.get("liveChatId");
  const videoId = searchParams.get("videoId");
  
  if (!liveChatId || liveChatId.length === 0) {
    return NextResponse.json({ error: "Параметр liveChatId обязателен" }, { status: 400 });
  }
  
  const encoder = new TextEncoder();
  const stream = new ReadableStream({
    async start(controller) {
      const youtube = createYoutubeClient(apiKey);
      let nextPageToken: string | undefined = undefined;
      let pollingInterval = 2000;
      let timer: NodeJS.Timeout | null = null;
      
      const poll = async () => {
        try {
          await ensureDatabaseInitialized();
          const data = await fetchMessages(youtube, liveChatId, nextPageToken);
          const items = data.items ?? [];
          const formattedMessages = items.map((item) => formatMessage(item));
          
          if (formattedMessages.length > 0) {
            const messagesToSave = formattedMessages.map((msg) => ({
              messageId: msg.messageId,
              videoId: videoId || undefined,
              liveChatId,
              authorName: msg.author,
              messageText: msg.text,
              publishedAt: msg.publishedAt,
            }));
            await saveMessages(messagesToSave);
            
            const messagesToSend = formattedMessages.map(({ messageId, publishedAt, ...rest }) => rest);
            const jsonData = JSON.stringify({ messages: messagesToSend });
            controller.enqueue(encoder.encode(`data: ${jsonData}\n\n`));
          }
          
          nextPageToken = data.nextPageToken ?? undefined;
          pollingInterval = data.pollingIntervalMillis ?? 2000;
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : "Неизвестная ошибка";
          controller.enqueue(encoder.encode(`data: ${JSON.stringify({ error: errorMessage })}\n\n`));
        }
        
        timer = setTimeout(poll, pollingInterval);
      };
      
      poll();
      
      request.signal.addEventListener("abort", () => {
        if (timer) {
          clearTimeout(timer);
        }
        controller.close();
      });
    },
  });
  
  return new Response(stream, {
    headers: {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      "Connection": "keep-alive",
    },
  });
}
</file>

<file path="app/api/messages/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createYoutubeClient, fetchMessages, formatMessage } from "@/lib/youtube-api";
import { saveMessages } from "@/lib/database";
import { ensureDatabaseInitialized } from "@/lib/db-init";

export async function GET(request: NextRequest) {
  const apiKey = process.env.YOUTUBE_API_KEY;
  
  if (!apiKey) {
    return NextResponse.json({ error: "YOUTUBE_API_KEY отсутствует в окружении" }, { status: 500 });
  }

  const searchParams = request.nextUrl.searchParams;
  const liveChatId = searchParams.get("liveChatId");
  const pageToken = searchParams.get("pageToken");
  const videoId = searchParams.get("videoId");

  if (!liveChatId || liveChatId.length === 0) {
    return NextResponse.json({ error: "Параметр liveChatId обязателен" }, { status: 400 });
  }

  try {
    await ensureDatabaseInitialized();
    const youtube = createYoutubeClient(apiKey);
    const data = await fetchMessages(youtube, liveChatId, pageToken || undefined);
    const items = data.items ?? [];
    const formattedMessages = items.map((item) => formatMessage(item));
    
    if (formattedMessages.length > 0) {
      const messagesToSave = formattedMessages.map((msg) => ({
        messageId: msg.messageId,
        videoId: videoId || undefined,
        liveChatId,
        authorName: msg.author,
        messageText: msg.text,
        publishedAt: msg.publishedAt,
      }));
      await saveMessages(messagesToSave);
    }
    
    return NextResponse.json({
      messages: formattedMessages.map(({ messageId, publishedAt, ...rest }) => rest),
      nextPageToken: data.nextPageToken ?? null,
      pollingIntervalMillis: data.pollingIntervalMillis ?? 2000,
    });
  } catch (error) {
    const message = error instanceof Error ? error.message : "Неизвестная ошибка";
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
</file>

<file path="app/api/overlay/route.ts">
import { NextResponse } from "next/server";

interface OverlayMessage {
  id: string;
  author: string;
  authorPhoto?: string;
  message: string;
  timestamp: number;
}

let currentOverlay: OverlayMessage | null = null;

export async function GET() {
  return NextResponse.json({ overlay: currentOverlay });
}

export async function POST(request: Request) {
  try {
    const body = await request.json();

    if (!body.author || !body.message) {
      return NextResponse.json(
        { error: "author and message are required" },
        { status: 400 }
      );
    }

    currentOverlay = {
      id: body.id || `${Date.now()}`,
      author: body.author,
      authorPhoto: body.authorPhoto,
      message: body.message,
      timestamp: Date.now(),
    };

    return NextResponse.json({ overlay: currentOverlay });
  } catch {
    return NextResponse.json(
      { error: "Invalid request body" },
      { status: 400 }
    );
  }
}

export async function DELETE() {
  currentOverlay = null;
  return NextResponse.json({ overlay: null });
}
</file>

<file path="app/api/quota/route.ts">
import { NextResponse } from "next/server";
import { Pool } from "pg";

const pool = new Pool({
  host: process.env.DB_HOST || "localhost",
  port: Number(process.env.DB_PORT || 5432),
  database: process.env.DB_NAME || "yt_chat",
  user: process.env.DB_USER || "postgres",
  password: process.env.DB_PASSWORD || "",
});

const DAILY_LIMIT = 10000;

export async function GET() {
  const client = await pool.connect();
  try {
    const todayStats = await client.query(`
      SELECT COALESCE(SUM(quota_cost), 0) as total_used
      FROM api_request_logs
      WHERE timestamp >= (NOW() AT TIME ZONE 'America/Los_Angeles')::date
                         AT TIME ZONE 'America/Los_Angeles'
    `);

    const byEndpoint = await client.query(`
      SELECT
        endpoint_type,
        COUNT(*)::int as count,
        SUM(quota_cost)::int as total_cost
      FROM api_request_logs
      WHERE timestamp >= (NOW() AT TIME ZONE 'America/Los_Angeles')::date
                         AT TIME ZONE 'America/Los_Angeles'
      GROUP BY endpoint_type
      ORDER BY total_cost DESC
    `);

    const used = Number(todayStats.rows[0].total_used);

    return NextResponse.json({
      today: {
        used,
        limit: DAILY_LIMIT,
      },
      byEndpoint: byEndpoint.rows.map((row) => ({
        endpoint: row.endpoint_type,
        count: row.count,
        cost: row.total_cost,
      })),
    });
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    return NextResponse.json({ error: message }, { status: 500 });
  } finally {
    client.release();
  }
}
</file>

<file path="app/api/videos/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createYoutubeClient, getChannelVideosWithDetails } from "@/lib/youtube-api";

export async function GET(request: NextRequest) {
  const apiKey = process.env.YOUTUBE_API_KEY;
  const channelId = process.env.YOUTUBE_CHANNEL_ID;

  if (!apiKey) {
    return NextResponse.json({ error: "YOUTUBE_API_KEY отсутствует в окружении" }, { status: 500 });
  }

  if (!channelId) {
    return NextResponse.json({ error: "YOUTUBE_CHANNEL_ID отсутствует в окружении" }, { status: 500 });
  }

  try {
    const youtube = createYoutubeClient(apiKey);
    const searchParams = request.nextUrl.searchParams;
    const maxResults = parseInt(searchParams.get("maxResults") || "50", 10);
    
    const videos = await getChannelVideosWithDetails(youtube, channelId, maxResults);
    
    return NextResponse.json({ videos });
  } catch (error) {
    let message = "Неизвестная ошибка";
    
    if (error instanceof Error) {
      message = error.message;
      if (message.includes("quota") || message.includes("exceeded")) {
        message = "Превышена квота YouTube API. Попробуйте позже или проверьте настройки API ключа.";
      } else if (message.includes("API key")) {
        message = "Неверный API ключ YouTube. Проверьте настройки окружения.";
      }
    }
    
    console.error("Ошибка при получении видео:", error);
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
</file>

<file path="app/quota/page.module.css">
.layout {
  width: min(960px, 100%);
  min-height: 100vh;
  margin: 0 auto;
  display: grid;
  grid-template-rows: auto 1fr;
  background: rgba(15, 23, 42, 0.85);
  border-radius: 16px;
  border: 1px solid rgba(148, 163, 184, 0.2);
  overflow: hidden;
  backdrop-filter: blur(16px);
}

.content {
  padding: 32px 24px;
}

.title {
  font-size: 28px;
  font-weight: 600;
  margin-bottom: 32px;
  color: var(--text);
}

.loading,
.error,
.empty {
  padding: 24px;
  text-align: center;
  color: var(--text-muted);
}

.error {
  color: var(--error);
}

/* Counter section */
.counter {
  padding: 24px;
  background: rgba(30, 41, 59, 0.85);
  border-radius: 12px;
  border: 1px solid rgba(56, 189, 248, 0.1);
  margin-bottom: 32px;
}

.counterLabel {
  font-size: 14px;
  color: var(--text-muted);
  margin-bottom: 8px;
}

.counterValue {
  font-size: 32px;
  font-weight: 700;
  color: var(--accent);
  margin-bottom: 16px;
}

.counterValue span {
  font-size: 20px;
  font-weight: 400;
  color: var(--text-muted);
}

.progressBar {
  height: 8px;
  background: rgba(148, 163, 184, 0.2);
  border-radius: 4px;
  overflow: hidden;
}

.progressFill {
  height: 100%;
  background: var(--accent);
  transition: width 0.3s;
}

/* Endpoint table */
.section {
  margin-bottom: 24px;
}

.sectionTitle {
  font-size: 16px;
  font-weight: 500;
  color: var(--text-muted);
  margin-bottom: 16px;
}

.table {
  width: 100%;
  border-collapse: collapse;
}

.table th {
  text-align: left;
  padding: 12px 16px;
  font-size: 12px;
  font-weight: 500;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  border-bottom: 1px solid rgba(148, 163, 184, 0.2);
}

.table th:last-child {
  text-align: right;
}

.table td {
  padding: 12px 16px;
  border-bottom: 1px solid rgba(148, 163, 184, 0.1);
}

.table td:last-child {
  text-align: right;
  font-weight: 600;
}

.endpoint {
  font-family: "SF Mono", "Monaco", "Consolas", monospace;
  font-size: 14px;
  color: var(--text);
}

.count {
  color: var(--text-muted);
  font-size: 14px;
}

@media (max-width: 640px) {
  .layout {
    border-radius: 0;
  }

  .content {
    padding: 24px 16px;
  }
}
</file>

<file path="app/quota/page.tsx">
"use client";

import { useEffect, useState } from "react";
import Navigation from "@/components/Navigation";
import styles from "./page.module.css";

interface QuotaStats {
  today: {
    used: number;
    limit: number;
  };
  byEndpoint: Array<{
    endpoint: string;
    count: number;
    cost: number;
  }>;
}

export default function QuotaPage() {
  const [stats, setStats] = useState<QuotaStats | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchStats = async () => {
      try {
        setLoading(true);
        const response = await fetch("/api/quota");
        if (!response.ok) {
          throw new Error("Не удалось загрузить статистику квоты");
        }
        const data = await response.json();
        setStats(data);
        setError(null);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Неизвестная ошибка");
      } finally {
        setLoading(false);
      }
    };

    fetchStats();
  }, []);

  const formatNumber = (num: number) => {
    return num.toLocaleString("ru-RU");
  };

  const getPercentage = () => {
    if (!stats) return 0;
    return Math.round((stats.today.used / stats.today.limit) * 100);
  };

  return (
    <div className={styles.layout}>
      <Navigation />
      <main className={styles.content}>
        <h1 className={styles.title}>Квота API</h1>

        {loading && <div className={styles.loading}>Загрузка...</div>}

        {error && <div className={styles.error}>{error}</div>}

        {stats && (
          <>
            <div className={styles.counter}>
              <div className={styles.counterLabel}>Использовано сегодня</div>
              <div className={styles.counterValue}>
                {formatNumber(stats.today.used)}{" "}
                <span>/ {formatNumber(stats.today.limit)} единиц</span>
              </div>
              <div className={styles.progressBar}>
                <div
                  className={styles.progressFill}
                  style={{ width: `${getPercentage()}%` }}
                />
              </div>
            </div>

            <div className={styles.section}>
              <h2 className={styles.sectionTitle}>Расход по операциям</h2>
              {stats.byEndpoint.length === 0 ? (
                <div className={styles.empty}>Нет данных за сегодня</div>
              ) : (
                <table className={styles.table}>
                  <thead>
                    <tr>
                      <th>Endpoint</th>
                      <th>Запросов</th>
                      <th>Стоимость</th>
                    </tr>
                  </thead>
                  <tbody>
                    {stats.byEndpoint.map((row) => (
                      <tr key={row.endpoint}>
                        <td className={styles.endpoint}>{row.endpoint}</td>
                        <td className={styles.count}>{row.count}</td>
                        <td>{formatNumber(row.cost)}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              )}
            </div>
          </>
        )}
      </main>
    </div>
  );
}
</file>

<file path="app/videos/page.module.css">
.layout {
  width: 100%;
  min-height: 100vh;
  display: grid;
  grid-template-rows: auto 1fr;
  background: rgba(15, 23, 42, 0.85);
}

.content {
  padding: 32px 24px;
  width: 100%;
  max-width: 100%;
}

.title {
  font-size: 28px;
  font-weight: 600;
  margin-bottom: 32px;
  color: var(--text);
}

.actions {
  display: flex;
  justify-content: flex-start;
  margin-bottom: 24px;
}

.loadButton {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 12px 20px;
  border-radius: 8px;
  border: none;
  background: var(--accent);
  color: #0f172a;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: transform 0.15s ease, box-shadow 0.15s ease, opacity 0.15s ease;
}

.loadButton:hover {
  transform: translateY(-1px);
  box-shadow: 0 12px 24px rgba(56, 189, 248, 0.35);
}

.loadButton:active {
  transform: translateY(0);
  box-shadow: none;
}

.loadButton:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

.loading,
.error,
.empty {
  padding: 24px;
  text-align: center;
  color: var(--text-muted);
}

.error {
  color: var(--error);
}

.grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
  gap: 24px;
  width: 100%;
}

.videoCard {
  background: rgba(30, 41, 59, 0.85);
  border-radius: 12px;
  border: 1px solid rgba(56, 189, 248, 0.1);
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.thumbnailContainer {
  width: 100%;
  aspect-ratio: 16 / 9;
  overflow: hidden;
  background: rgba(0, 0, 0, 0.3);
}

.thumbnail {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.videoInfo {
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  flex: 1;
}

.videoTitle {
  font-size: 18px;
  font-weight: 600;
  color: var(--text);
  margin: 0;
  line-height: 1.4;
}

.videoMeta {
  display: flex;
  align-items: center;
  gap: 12px;
}

.publishedDate {
  font-size: 14px;
  color: var(--text-muted);
}

.descriptionContainer {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-top: 8px;
}

.descriptionLabel {
  font-size: 14px;
  font-weight: 500;
  color: var(--text-muted);
}

.descriptionInput {
  width: 100%;
  padding: 12px;
  background: rgba(15, 23, 42, 0.6);
  border: 1px solid rgba(148, 163, 184, 0.2);
  border-radius: 8px;
  color: var(--text);
  font-size: 14px;
  font-family: inherit;
  line-height: 1.5;
  resize: vertical;
  min-height: 120px;
  transition: border-color 0.2s ease;
}

.descriptionInput:focus {
  outline: none;
  border-color: var(--accent);
}

.descriptionInput::placeholder {
  color: var(--text-muted);
}

@media (max-width: 1024px) {
  .grid {
    grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
  }
}

@media (max-width: 768px) {
  .content {
    padding: 24px 16px;
  }

  .grid {
    grid-template-columns: 1fr;
    gap: 20px;
  }
}

@media (max-width: 480px) {
  .content {
    padding: 20px 12px;
  }

  .title {
    font-size: 24px;
    margin-bottom: 24px;
  }

  .videoInfo {
    padding: 16px;
  }

  .videoTitle {
    font-size: 16px;
  }
}
</file>

<file path="app/videos/page.tsx">
"use client";

import { useState } from "react";
import Navigation from "@/components/Navigation";
import styles from "./page.module.css";

interface Video {
  id: string;
  title: string;
  description: string;
  publishedAt: string;
  thumbnail: string;
  channelId: string;
  channelTitle: string;
}

export default function VideosPage() {
  const [videos, setVideos] = useState<Video[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [descriptions, setDescriptions] = useState<Record<string, string>>({});
  const [hasLoaded, setHasLoaded] = useState(false);

  const fetchVideos = async () => {
    if (loading) {
      return;
    }

    try {
      setLoading(true);
      const response = await fetch("/api/videos");
      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || "Не удалось загрузить видео");
      }

      setVideos(data.videos || []);

      const initialDescriptions: Record<string, string> = {};
      data.videos?.forEach((video: Video) => {
        initialDescriptions[video.id] = video.description || "";
      });
      setDescriptions(initialDescriptions);

      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Неизвестная ошибка");
    } finally {
      setLoading(false);
      setHasLoaded(true);
    }
  };

  const handleDescriptionChange = (videoId: string, value: string) => {
    setDescriptions((prev) => ({
      ...prev,
      [videoId]: value,
    }));
  };

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleDateString("ru-RU", {
      year: "numeric",
      month: "long",
      day: "numeric",
    });
  };

  return (
    <div className={styles.layout}>
      <Navigation />
      <main className={styles.content}>
        <h1 className={styles.title}>Видео</h1>

        <div className={styles.actions}>
          <button
            className={styles.loadButton}
            onClick={fetchVideos}
            disabled={loading}
          >
            {loading ? "Загрузка..." : hasLoaded ? "Обновить список" : "Загрузить видео"}
          </button>
        </div>
        
        {error && <div className={styles.error}>{error}</div>}

        {!loading && hasLoaded && !error && videos.length === 0 && (
          <div className={styles.empty}>Видео не найдены</div>
        )}
        
        {!loading && !error && videos.length > 0 && (
          <div className={styles.grid}>
            {videos.map((video) => (
              <div key={video.id} className={styles.videoCard}>
                <div className={styles.thumbnailContainer}>
                  <img
                    src={video.thumbnail}
                    alt={video.title}
                    className={styles.thumbnail}
                  />
                </div>
                <div className={styles.videoInfo}>
                  <h3 className={styles.videoTitle}>{video.title}</h3>
                  <div className={styles.videoMeta}>
                    <span className={styles.publishedDate}>
                      {formatDate(video.publishedAt)}
                    </span>
                  </div>
                  <div className={styles.descriptionContainer}>
                    <label className={styles.descriptionLabel}>
                      Описание:
                    </label>
                    <textarea
                      className={styles.descriptionInput}
                      value={descriptions[video.id] || ""}
                      onChange={(e) =>
                        handleDescriptionChange(video.id, e.target.value)
                      }
                      placeholder="Введите описание видео..."
                      rows={6}
                    />
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
      </main>
    </div>
  );
}
</file>

<file path="docs/plans/2025-12-07-overlay-moderation-design.md">
# Overlay Moderation Feature Design

## Overview

Фича для показа выбранных комментариев из чата в OBS оверлее во время стрима. Стример выбирает комментарий в админке, он появляется в оверлее с typewriter анимацией, зрители видят на какой вопрос отвечает стример.

## User Flow

1. Стример открывает `/transmissions` и `/obs` (в OBS Browser Source)
2. Во время стрима видит интересный комментарий в чате
3. Нажимает кнопку "показать в оверлее" рядом с комментарием
4. Комментарий появляется в OBS с typewriter анимацией
5. Стример отвечает голосом
6. Нажимает "убрать из оверлея"
7. Комментарий исчезает

## Architecture

### API Endpoint: `/api/overlay`

```typescript
// app/api/overlay/route.ts

interface OverlayMessage {
  id: string
  author: string
  authorPhoto?: string
  message: string
  timestamp: number
}

let currentOverlay: OverlayMessage | null = null

// GET — получить текущий комментарий
// POST — установить комментарий
// DELETE — очистить оверлей
```

### Data Flow

```
[/transmissions] --POST--> [/api/overlay] <--GET(polling)-- [/obs]
                 --DELETE->
```

Состояние хранится в памяти сервера (переменная модуля). Для локального использования этого достаточно.

## UI Changes

### /transmissions

**Кнопка выбора (на каждом сообщении):**
- Иконка "📺" справа от сообщения
- При клике: POST `/api/overlay` с данными сообщения
- Активный комментарий выделяется рамкой/цветом

**Панель управления оверлеем (вверху чата):**
- Индикатор статуса: "В оверлее: {автор}" или "Оверлей пуст"
- Кнопка "Убрать из оверлея" (DELETE `/api/overlay`)

### /obs

**Блок выбранного комментария:**
- Расположение: отдельный блок, не мешает основному чату
- Прозрачный когда пуст
- Polling: GET `/api/overlay` каждые 1.5 секунды

**Анимация появления:**
1. Fade-in контейнера (~0.3s)
2. Имя автора показывается сразу
3. Текст печатается посимвольно (~50ms на символ)

**Анимация исчезновения:**
- Fade-out (~0.3s)

**Стилизация:**
- Полупрозрачный фон
- Аватар автора (опционально)
- Имя автора выделено цветом
- Крупный читаемый текст

## Implementation Tasks

1. Создать `/api/overlay/route.ts` с GET/POST/DELETE
2. Добавить кнопку выбора к сообщениям в `/transmissions`
3. Добавить панель управления оверлеем в `/transmissions`
4. Создать компонент оверлея с typewriter анимацией
5. Интегрировать оверлей в `/obs` с polling

## Technical Notes

- Polling интервал 1.5s — баланс между отзывчивостью и нагрузкой
- Typewriter скорость ~50ms/символ — читаемо, но не слишком медленно
- Состояние в памяти сбрасывается при перезапуске сервера (приемлемо для MVP)
</file>

<file path="docs/plans/2025-12-23-quota-page-design.md">
# Quota Page Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Создать страницу `/quota` для мониторинга расхода квоты YouTube API

**Architecture:** API endpoint читает из `api_request_logs` (PostgreSQL), фильтрует по Pacific Time, группирует по endpoint. React страница отображает счётчик и таблицу.

**Tech Stack:** Next.js 14 (App Router), PostgreSQL, CSS Modules

---

## Task 1: API Endpoint

**Files:**
- Create: `app/api/quota/route.ts`

**Step 1: Create API route file**

```typescript
// app/api/quota/route.ts
import { NextResponse } from "next/server";
import { Pool } from "pg";

const pool = new Pool({
  host: process.env.DB_HOST || "localhost",
  port: Number(process.env.DB_PORT || 5432),
  database: process.env.DB_NAME || "yt_chat",
  user: process.env.DB_USER || "postgres",
  password: process.env.DB_PASSWORD || "",
});

const DAILY_LIMIT = 10000;

export async function GET() {
  const client = await pool.connect();
  try {
    const todayStats = await client.query(`
      SELECT COALESCE(SUM(quota_cost), 0) as total_used
      FROM api_request_logs
      WHERE timestamp >= (NOW() AT TIME ZONE 'America/Los_Angeles')::date
                         AT TIME ZONE 'America/Los_Angeles'
    `);

    const byEndpoint = await client.query(`
      SELECT
        endpoint_type,
        COUNT(*)::int as count,
        SUM(quota_cost)::int as total_cost
      FROM api_request_logs
      WHERE timestamp >= (NOW() AT TIME ZONE 'America/Los_Angeles')::date
                         AT TIME ZONE 'America/Los_Angeles'
      GROUP BY endpoint_type
      ORDER BY total_cost DESC
    `);

    const used = Number(todayStats.rows[0].total_used);

    return NextResponse.json({
      today: {
        used,
        limit: DAILY_LIMIT,
      },
      byEndpoint: byEndpoint.rows.map((row) => ({
        endpoint: row.endpoint_type,
        count: row.count,
        cost: row.total_cost,
      })),
    });
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    return NextResponse.json({ error: message }, { status: 500 });
  } finally {
    client.release();
  }
}
```

**Step 2: Verify API works**

Run: `curl http://localhost:3000/api/quota`

Expected: JSON response with `today` and `byEndpoint` fields

**Step 3: Commit**

```bash
git add app/api/quota/route.ts
git commit -m "feat: add /api/quota endpoint for quota monitoring"
```

---

## Task 2: Page Styles

**Files:**
- Create: `app/quota/page.module.css`

**Step 1: Create styles file**

```css
/* app/quota/page.module.css */
.layout {
  width: min(960px, 100%);
  min-height: 100vh;
  margin: 0 auto;
  display: grid;
  grid-template-rows: auto 1fr;
  background: rgba(15, 23, 42, 0.85);
  border-radius: 16px;
  border: 1px solid rgba(148, 163, 184, 0.2);
  overflow: hidden;
  backdrop-filter: blur(16px);
}

.content {
  padding: 32px 24px;
}

.title {
  font-size: 28px;
  font-weight: 600;
  margin-bottom: 32px;
  color: var(--text);
}

.loading,
.error,
.empty {
  padding: 24px;
  text-align: center;
  color: var(--text-muted);
}

.error {
  color: var(--error);
}

/* Counter section */
.counter {
  padding: 24px;
  background: rgba(30, 41, 59, 0.85);
  border-radius: 12px;
  border: 1px solid rgba(56, 189, 248, 0.1);
  margin-bottom: 32px;
}

.counterLabel {
  font-size: 14px;
  color: var(--text-muted);
  margin-bottom: 8px;
}

.counterValue {
  font-size: 32px;
  font-weight: 700;
  color: var(--accent);
  margin-bottom: 16px;
}

.counterValue span {
  font-size: 20px;
  font-weight: 400;
  color: var(--text-muted);
}

.progressBar {
  height: 8px;
  background: rgba(148, 163, 184, 0.2);
  border-radius: 4px;
  overflow: hidden;
}

.progressFill {
  height: 100%;
  background: var(--accent);
  transition: width 0.3s;
}

/* Endpoint table */
.section {
  margin-bottom: 24px;
}

.sectionTitle {
  font-size: 16px;
  font-weight: 500;
  color: var(--text-muted);
  margin-bottom: 16px;
}

.table {
  width: 100%;
  border-collapse: collapse;
}

.table th {
  text-align: left;
  padding: 12px 16px;
  font-size: 12px;
  font-weight: 500;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  border-bottom: 1px solid rgba(148, 163, 184, 0.2);
}

.table th:last-child {
  text-align: right;
}

.table td {
  padding: 12px 16px;
  border-bottom: 1px solid rgba(148, 163, 184, 0.1);
}

.table td:last-child {
  text-align: right;
  font-weight: 600;
}

.endpoint {
  font-family: "SF Mono", "Monaco", "Consolas", monospace;
  font-size: 14px;
  color: var(--text);
}

.count {
  color: var(--text-muted);
  font-size: 14px;
}

@media (max-width: 640px) {
  .layout {
    border-radius: 0;
  }

  .content {
    padding: 24px 16px;
  }
}
```

**Step 2: Commit**

```bash
git add app/quota/page.module.css
git commit -m "feat: add styles for quota page"
```

---

## Task 3: Page Component

**Files:**
- Create: `app/quota/page.tsx`

**Step 1: Create page component**

```tsx
// app/quota/page.tsx
"use client";

import { useEffect, useState } from "react";
import Navigation from "@/components/Navigation";
import styles from "./page.module.css";

interface QuotaStats {
  today: {
    used: number;
    limit: number;
  };
  byEndpoint: Array<{
    endpoint: string;
    count: number;
    cost: number;
  }>;
}

export default function QuotaPage() {
  const [stats, setStats] = useState<QuotaStats | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchStats = async () => {
      try {
        setLoading(true);
        const response = await fetch("/api/quota");
        if (!response.ok) {
          throw new Error("Не удалось загрузить статистику квоты");
        }
        const data = await response.json();
        setStats(data);
        setError(null);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Неизвестная ошибка");
      } finally {
        setLoading(false);
      }
    };

    fetchStats();
  }, []);

  const formatNumber = (num: number) => {
    return num.toLocaleString("ru-RU");
  };

  const getPercentage = () => {
    if (!stats) return 0;
    return Math.round((stats.today.used / stats.today.limit) * 100);
  };

  return (
    <div className={styles.layout}>
      <Navigation />
      <main className={styles.content}>
        <h1 className={styles.title}>Квота API</h1>

        {loading && <div className={styles.loading}>Загрузка...</div>}

        {error && <div className={styles.error}>{error}</div>}

        {stats && (
          <>
            <div className={styles.counter}>
              <div className={styles.counterLabel}>Использовано сегодня</div>
              <div className={styles.counterValue}>
                {formatNumber(stats.today.used)}{" "}
                <span>/ {formatNumber(stats.today.limit)} единиц</span>
              </div>
              <div className={styles.progressBar}>
                <div
                  className={styles.progressFill}
                  style={{ width: `${getPercentage()}%` }}
                />
              </div>
            </div>

            <div className={styles.section}>
              <h2 className={styles.sectionTitle}>Расход по операциям</h2>
              {stats.byEndpoint.length === 0 ? (
                <div className={styles.empty}>Нет данных за сегодня</div>
              ) : (
                <table className={styles.table}>
                  <thead>
                    <tr>
                      <th>Endpoint</th>
                      <th>Запросов</th>
                      <th>Стоимость</th>
                    </tr>
                  </thead>
                  <tbody>
                    {stats.byEndpoint.map((row) => (
                      <tr key={row.endpoint}>
                        <td className={styles.endpoint}>{row.endpoint}</td>
                        <td className={styles.count}>{row.count}</td>
                        <td>{formatNumber(row.cost)}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              )}
            </div>
          </>
        )}
      </main>
    </div>
  );
}
```

**Step 2: Verify page renders**

Open: `http://localhost:3000/quota`

Expected: Page with counter showing "0 / 10,000 единиц" and empty table (or data if logs exist)

**Step 3: Commit**

```bash
git add app/quota/page.tsx
git commit -m "feat: add quota monitoring page"
```

---

## Task 4: Navigation Link

**Files:**
- Modify: `components/Navigation.tsx:25-29`

**Step 1: Add link to navigation**

Add after the "Видео" link (line 29):

```tsx
      <Link
        href="/quota"
        className={`${styles.link} ${pathname === "/quota" ? styles.active : ""}`}
      >
        Квота
      </Link>
```

**Step 2: Verify navigation**

Open: `http://localhost:3000/quota`

Expected: "Квота" link visible in navigation, highlighted when on `/quota` page

**Step 3: Commit**

```bash
git add components/Navigation.tsx
git commit -m "feat: add quota link to navigation"
```

---

## Verification Checklist

- [ ] `curl http://localhost:3000/api/quota` returns valid JSON
- [ ] `/quota` page loads without errors
- [ ] Counter shows current usage
- [ ] Table shows breakdown by endpoint (or "Нет данных" if empty)
- [ ] Navigation link works and highlights correctly
- [ ] Styling matches other pages (dark theme, same fonts)
</file>

<file path="docs/youtube-api-quota.md">
# YouTube Data API v3 Quota

## Лимиты

| Параметр | Значение |
|----------|----------|
| Дневной лимит по умолчанию | **10,000 единиц** |
| Сброс квоты | Полночь по Pacific Time (PT) |
| Привязка | К Google Cloud проекту (не к API ключу) |

Несколько API ключей в одном проекте делят общую квоту.

## Стоимость операций

| Метод | Стоимость | Используется в проекте |
|-------|-----------|------------------------|
| `search.list` | **100** | `getLiveBroadcasts`, `getChannelVideos` |
| `videos.list` | 1 | `getLiveChatId`, `getVideosDetails` |
| `channels.list` | 1 | `getChannelStats` |
| `liveChatMessages.list` | ~5* | `fetchMessages` (polling) |
| `videos.update` | 50 | - |
| `videos.insert` | 1,600 | - |

*Точная стоимость `liveChatMessages.list` не указана в документации. Оценка 5 единиц.

## Расчёт для типичных сценариев

### Проверка активной трансляции
- `search.list` (eventType=live) = **100 единиц**

### Polling чата (1 час стрима)
- Интервал 5 сек = 720 запросов/час
- `liveChatMessages.list` × 720 = **~3,600 единиц**

### Загрузка списка видео
- `search.list` = 100
- `videos.list` (детали) = 1
- Итого: **101 единица**

### Просмотр статистики канала
- `channels.list` = **1 единица**

## Проблемные места в проекте

1. **`search.list` для проверки трансляции** — 100 единиц каждый раз
   - При polling каждые 30 сек = 2,880 единиц/день только на проверку

2. **`search.list` для списка видео** — 100 единиц
   - Решено: кнопка ручной загрузки

## Оптимизация

### 1. Использовать `fields` параметр
```typescript
youtube.videos.list({
  part: ["snippet"],
  id: [videoId],
  fields: "items(id,snippet/title)" // только нужные поля
})
```

### 2. Batch запросы
```typescript
// Плохо: 5 запросов = 5 единиц
for (const id of videoIds) {
  await youtube.videos.list({ id: [id] })
}

// Хорошо: 1 запрос = 1 единица
await youtube.videos.list({ id: videoIds })
```

### 3. ETags для кэширования
Если ресурс не изменился, возвращается `304 Not Modified` без расхода квоты.

### 4. Заменить `search.list` на `playlistItems.list`
Для получения видео канала использовать uploads playlist:
```typescript
// Стоимость: 1 единица вместо 100
const uploadsPlaylistId = "UU" + channelId.slice(2)
youtube.playlistItems.list({
  playlistId: uploadsPlaylistId,
  part: ["snippet"],
  maxResults: 50
})
```

### 5. Увеличить интервал проверки трансляции
Вместо polling каждые 5 сек — проверять реже или по событию.

## Увеличение квоты

Можно запросить увеличение через [Google Cloud Console](https://console.cloud.google.com/apis/api/youtube.googleapis.com/quotas).

Требования:
- Описание use case
- Соответствие YouTube API Terms of Service
- Прохождение compliance audit (для больших квот)

## Источники

- [Quota Calculator](https://developers.google.com/youtube/v3/determine_quota_cost)
- [Quota and Compliance Audits](https://developers.google.com/youtube/v3/guides/quota_and_compliance_audits)
- [YouTube API Quota Guide 2025](https://getlate.dev/blog/youtube-api-limits-how-to-calculate-api-usage-cost-and-fix-exceeded-api-quota)
</file>

<file path="lib/api-logger-client.ts">
import { EventEmitter } from "events";

// Event emitter for real-time activity indicator (client-side only)
export const logEmitter = new EventEmitter();
</file>

<file path="lib/api-logger.ts">
import { Pool } from "pg";
import { logEmitter } from "./api-logger-client";

const pool = new Pool({
  host: process.env.DB_HOST || "localhost",
  port: Number(process.env.DB_PORT || 5432),
  database: process.env.DB_NAME || "yt_chat",
  user: process.env.DB_USER || "postgres",
  password: process.env.DB_PASSWORD || "",
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});

// Quota costs based on YouTube Data API v3 documentation
export const QUOTA_COSTS = {
  "search.list": 100,
  "videos.list": 1,
  "channels.list": 1,
  "liveChatMessages.list": 5,
} as const;

export interface ApiLogEntry {
  id?: number;
  timestamp: Date;
  endpointType: string;
  methodName: string;
  requestParams?: Record<string, any>;
  status: "success" | "error";
  errorMessage?: string;
  quotaCost: number;
  responseTimeMs: number;
}

// Event emitter is exported from api-logger-client.ts
export { logEmitter } from "./api-logger-client";

/**
 * Save a log entry to the database
 */
async function saveLogToDatabase(log: ApiLogEntry): Promise<void> {
  const client = await pool.connect();
  try {
    await client.query(
      `INSERT INTO api_request_logs 
        (timestamp, endpoint_type, method_name, request_params, status, error_message, quota_cost, response_time_ms)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
      [
        log.timestamp,
        log.endpointType,
        log.methodName,
        log.requestParams ? JSON.stringify(log.requestParams) : null,
        log.status,
        log.errorMessage || null,
        log.quotaCost,
        log.responseTimeMs,
      ]
    );
  } catch (error) {
    console.error("Failed to save API log to database:", error);
  } finally {
    client.release();
  }
}

/**
 * Log an API request
 */
export async function logApiRequest(
  methodName: string,
  endpointType: keyof typeof QUOTA_COSTS,
  requestParams: Record<string, any> | undefined,
  status: "success" | "error",
  responseTimeMs: number,
  errorMessage?: string
): Promise<void> {
  const log: ApiLogEntry = {
    timestamp: new Date(),
    methodName,
    endpointType,
    requestParams,
    status,
    errorMessage,
    quotaCost: QUOTA_COSTS[endpointType] || 0,
    responseTimeMs,
  };

  // Emit event for real-time activity indicator
  logEmitter.emit("newLog", log);

  // Save to database asynchronously (don't await to avoid blocking)
  saveLogToDatabase(log).catch((error) => {
    console.error("Error saving API log:", error);
  });
}
</file>

<file path="src/utils/database.ts">
import { Pool } from "pg";
import dotenv from "dotenv";

dotenv.config();

const pool = new Pool({
  host: process.env.DB_HOST || "localhost",
  port: Number(process.env.DB_PORT || 5432),
  database: process.env.DB_NAME || "yt_chat",
  user: process.env.DB_USER || "postgres",
  password: process.env.DB_PASSWORD || "",
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});

export async function initDatabase() {
  const client = await pool.connect();
  try {
    await client.query(`
      CREATE TABLE IF NOT EXISTS chat_messages (
        id SERIAL PRIMARY KEY,
        message_id VARCHAR(255) UNIQUE NOT NULL,
        video_id VARCHAR(255),
        live_chat_id VARCHAR(255),
        author_name VARCHAR(255) NOT NULL,
        message_text TEXT NOT NULL,
        published_at TIMESTAMP NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
      
      CREATE INDEX IF NOT EXISTS idx_message_id ON chat_messages(message_id);
      CREATE INDEX IF NOT EXISTS idx_video_id ON chat_messages(video_id);
      CREATE INDEX IF NOT EXISTS idx_published_at ON chat_messages(published_at DESC);
    `);
  } finally {
    client.release();
  }
}

export interface ChatMessage {
  messageId: string;
  videoId?: string;
  liveChatId?: string;
  authorName: string;
  messageText: string;
  publishedAt: Date;
}

export async function saveMessage(message: ChatMessage): Promise<void> {
  const client = await pool.connect();
  try {
    await client.query(
      `INSERT INTO chat_messages (message_id, video_id, live_chat_id, author_name, message_text, published_at)
       VALUES ($1, $2, $3, $4, $5, $6)
       ON CONFLICT (message_id) DO NOTHING`,
      [
        message.messageId,
        message.videoId || null,
        message.liveChatId || null,
        message.authorName,
        message.messageText,
        message.publishedAt,
      ]
    );
  } finally {
    client.release();
  }
}

export async function saveMessages(messages: ChatMessage[]): Promise<void> {
  if (messages.length === 0) return;
  
  const client = await pool.connect();
  try {
    await client.query("BEGIN");
    for (const message of messages) {
      await client.query(
        `INSERT INTO chat_messages (message_id, video_id, live_chat_id, author_name, message_text, published_at)
         VALUES ($1, $2, $3, $4, $5, $6)
         ON CONFLICT (message_id) DO NOTHING`,
        [
          message.messageId,
          message.videoId || null,
          message.liveChatId || null,
          message.authorName,
          message.messageText,
          message.publishedAt,
        ]
      );
    }
    await client.query("COMMIT");
  } catch (error) {
    await client.query("ROLLBACK");
    throw error;
  } finally {
    client.release();
  }
}

export async function getMessages(
  limit: number = 100,
  offset: number = 0,
  videoId?: string
): Promise<ChatMessage[]> {
  const client = await pool.connect();
  try {
    let query = `
      SELECT message_id, video_id, live_chat_id, author_name, message_text, published_at
      FROM chat_messages
    `;
    const params: any[] = [];
    
    if (videoId) {
      query += ` WHERE video_id = $1`;
      params.push(videoId);
    }
    
    query += ` ORDER BY published_at DESC LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
    params.push(limit, offset);
    
    const result = await client.query(query, params);
    return result.rows.map((row) => ({
      messageId: row.message_id,
      videoId: row.video_id,
      liveChatId: row.live_chat_id,
      authorName: row.author_name,
      messageText: row.message_text,
      publishedAt: row.published_at,
    }));
  } finally {
    client.release();
  }
}

export async function closeDatabase(): Promise<void> {
  await pool.end();
}
</file>

<file path="src/get-channel-data.ts">
import dotenv from "dotenv";
import { google } from "googleapis";

dotenv.config();

const apiKey = process.env.YOUTUBE_API_KEY;
const channelId = process.env.YOUTUBE_CHANNEL_ID;
const channelUsername = process.env.YOUTUBE_CHANNEL_USERNAME;
const channelHandle = process.env.YOUTUBE_CHANNEL_HANDLE;

if (!apiKey) {
  throw new Error("YOUTUBE_API_KEY отсутствует в окружении");
}

const youtube = google.youtube({ version: "v3", auth: apiKey });

async function getChannelIdByHandle(handle: string): Promise<string | null> {
  try {
    const cleanHandle = handle.startsWith("@") ? handle : `@${handle}`;
    const response = await youtube.channels.list({
      part: ["id"],
      forHandle: cleanHandle,
    } as any);
    return response.data.items?.[0]?.id || null;
  } catch (error) {
    return null;
  }
}

async function getChannelIdByUsername(username: string): Promise<string | null> {
  try {
    const response = await youtube.channels.list({
      part: ["id"],
      forUsername: username,
    });
    return response.data.items?.[0]?.id || null;
  } catch (error) {
    return null;
  }
}

async function getChannelData(channelId: string) {
  const response = await youtube.channels.list({
    part: ["snippet", "statistics", "contentDetails"],
    id: [channelId],
  });
  return response.data.items?.[0];
}

async function getChannelVideos(channelId: string, maxResults: number = 10) {
  const response = await youtube.search.list({
    part: ["snippet"],
    channelId: channelId,
    type: "video",
    order: "date",
    maxResults: maxResults,
  } as any);
  return response.data?.items || [];
}

async function getLiveBroadcasts(channelId: string) {
  const response = await youtube.search.list({
    part: ["snippet"],
    channelId: channelId,
    type: "video",
    eventType: "live",
    maxResults: 10,
  } as any);
  return response.data?.items || [];
}

async function getUpcomingBroadcasts(channelId: string) {
  const response = await youtube.search.list({
    part: ["snippet"],
    channelId: channelId,
    type: "video",
    eventType: "upcoming",
    maxResults: 10,
  } as any);
  return response.data?.items || [];
}

async function run() {
  try {
    console.log("Получение данных канала...\n");

    let targetChannelId: string | undefined = channelId;

    if (!targetChannelId && channelHandle) {
      console.log(`Поиск канала по handle: ${channelHandle}`);
      const foundId = await getChannelIdByHandle(channelHandle);
      if (!foundId) {
        throw new Error(`Не удалось найти канал с handle: ${channelHandle}`);
      }
      targetChannelId = foundId;
      console.log(`Найден channel ID: ${targetChannelId}\n`);
    }

    if (!targetChannelId && channelUsername) {
      console.log(`Поиск канала по username: ${channelUsername}`);
      const foundId = await getChannelIdByUsername(channelUsername);
      if (!foundId) {
        throw new Error(`Не удалось найти канал с username: ${channelUsername}`);
      }
      targetChannelId = foundId;
      console.log(`Найден channel ID: ${targetChannelId}\n`);
    }

    if (!targetChannelId) {
      throw new Error("Укажите YOUTUBE_CHANNEL_ID, YOUTUBE_CHANNEL_HANDLE или YOUTUBE_CHANNEL_USERNAME в .env файле");
    }

    console.log("=== Информация о канале ===");
    const channelData = await getChannelData(targetChannelId);
    if (channelData) {
      console.log("Название:", channelData.snippet?.title);
      console.log("Описание:", channelData.snippet?.description?.substring(0, 100) + "...");
      console.log("Подписчиков:", channelData.statistics?.subscriberCount);
      console.log("Всего видео:", channelData.statistics?.videoCount);
      console.log("Просмотров:", channelData.statistics?.viewCount);
      console.log("Дата создания:", channelData.snippet?.publishedAt);
      console.log("Ссылка:", `https://www.youtube.com/channel/${targetChannelId}`);
    }

    console.log("\n=== Последние видео ===");
    const videos = await getChannelVideos(targetChannelId, 5);
    if (videos.length > 0) {
      videos.forEach((video: any, index: number) => {
        console.log(`${index + 1}. ${video.snippet?.title}`);
        console.log(`   Опубликовано: ${video.snippet?.publishedAt}`);
        console.log(`   ID видео: ${video.id?.videoId}`);
        console.log();
      });
    } else {
      console.log("Видео не найдены");
    }

    console.log("=== Активные трансляции ===");
    const liveBroadcasts = await getLiveBroadcasts(targetChannelId);
    if (liveBroadcasts.length > 0) {
      liveBroadcasts.forEach((broadcast: any, index: number) => {
        console.log(`${index + 1}. ${broadcast.snippet?.title}`);
        console.log(`   ID видео: ${broadcast.id?.videoId}`);
        console.log(`   Начало: ${broadcast.snippet?.publishedAt}`);
        console.log();
      });
    } else {
      console.log("Активных трансляций нет");
    }

    console.log("=== Предстоящие трансляции ===");
    const upcomingBroadcasts = await getUpcomingBroadcasts(targetChannelId);
    if (upcomingBroadcasts.length > 0) {
      upcomingBroadcasts.forEach((broadcast: any, index: number) => {
        console.log(`${index + 1}. ${broadcast.snippet?.title}`);
        console.log(`   ID видео: ${broadcast.id?.videoId}`);
        console.log(`   Запланировано: ${broadcast.snippet?.publishedAt}`);
        console.log();
      });
    } else {
      console.log("Предстоящих трансляций нет");
    }

  } catch (error) {
    if (error instanceof Error) {
      console.error("❌ Ошибка:", error.message);
    } else {
      console.error("❌ Неизвестная ошибка:", error);
    }
    process.exit(1);
  }
}

run();
</file>

<file path="src/test-channel-serejaris.ts">
import dotenv from "dotenv";
import { youtube_v3 } from "googleapis";
import { createYoutubeClient, fetchMessages, formatMessage, getLiveBroadcasts, getLiveChatId } from "./utils/youtube-api";

dotenv.config();

const apiKey = process.env.YOUTUBE_API_KEY;

if (!apiKey) {
  throw new Error("YOUTUBE_API_KEY отсутствует в окружении");
}

const youtube = createYoutubeClient(apiKey);
const channelHandle = process.env.YOUTUBE_CHANNEL_HANDLE ?? "@serejaris";

async function getChannelIdByHandle(handle: string): Promise<string | null> {
  const cleanHandle = handle.startsWith("@") ? handle : `@${handle}`;
  try {
    const response = await youtube.channels.list({
      part: ["id"],
      forHandle: cleanHandle,
    } as youtube_v3.Params$Resource$Channels$List);
    return response.data.items?.[0]?.id || null;
  } catch (error) {
    if (error instanceof Error) {
      console.error(`Ошибка при поиске handle ${cleanHandle}:`, error.message);
    }
    return null;
  }
}

async function getChannelData(channelId: string) {
  const response = await youtube.channels.list({
    part: ["snippet", "statistics", "contentDetails"],
    id: [channelId],
  });
  return response.data.items?.[0];
}

async function getChannelVideos(channelId: string, maxResults: number = 10) {
  const response = await youtube.search.list({
    part: ["snippet"],
    channelId,
    type: ["video"],
    order: "date",
    maxResults,
  } as youtube_v3.Params$Resource$Search$List);
  return response.data?.items || [];
}

async function testChannel() {
  try {
    const safeApiKey = apiKey as string;
    console.log(`Тестирование канала ${channelHandle}...\n`);
    console.log(`API ключ: ${safeApiKey.substring(0, 10)}...\n`);

    const channelId = await getChannelIdByHandle(channelHandle);

    if (!channelId) {
      throw new Error(`Не удалось найти канал с handle: ${channelHandle}`);
    }

    console.log(`✅ Канал найден! Channel ID: ${channelId}\n`);

    console.log("=== Информация о канале ===");
    const channelData = await getChannelData(channelId);
    if (channelData) {
      console.log("Название:", channelData.snippet?.title);
      console.log("Описание:", channelData.snippet?.description?.substring(0, 100) + "...");
      console.log("Подписчиков:", channelData.statistics?.subscriberCount);
      console.log("Всего видео:", channelData.statistics?.videoCount);
      console.log("Просмотров:", channelData.statistics?.viewCount);
      console.log("Дата создания:", channelData.snippet?.publishedAt);
      console.log("Ссылка:", `https://www.youtube.com/channel/${channelId}`);
    }

    console.log("\n=== Последние видео ===");
    const videos = await getChannelVideos(channelId, 5);
    if (videos.length > 0) {
      videos.forEach((video: any, index: number) => {
        console.log(`${index + 1}. ${video.snippet?.title}`);
        console.log(`   Опубликовано: ${video.snippet?.publishedAt}`);
        console.log(`   ID видео: ${video.id?.videoId}`);
        console.log();
      });
    } else {
      console.log("Видео не найдены");
    }

    console.log("\n=== Поиск активной трансляции ===");
    const liveBroadcasts = await getLiveBroadcasts(youtube, channelId);
    if (liveBroadcasts.length === 0) {
      console.log("❌ Активных трансляций не найдено");
      console.log("\n✅ Тест завершен. API работает корректно, но трансляций нет.");
      return;
    }

    const firstLiveVideo = liveBroadcasts[0];
    const videoId = firstLiveVideo.id?.videoId;
    if (!videoId) {
      throw new Error("Не удалось получить ID видео трансляции");
    }

    console.log(`Найдена трансляция: ${firstLiveVideo.snippet?.title}`);
    console.log(`ID видео: ${videoId}`);

    console.log("\n=== Получение Live Chat ID ===");
    const chatId = await getLiveChatId(youtube, videoId);
    if (!chatId) {
      console.log("❌ Не удалось получить Live Chat ID");
      console.log("Возможно, трансляция не имеет активного чата или чат отключен");
      return;
    }

    console.log(`✅ Live Chat ID найден: ${chatId}`);

    console.log("\n=== Тестирование получения сообщений ===");
    const messagesData = await fetchMessages(youtube, chatId);
    const messages = messagesData.items || [];

    if (messages.length === 0) {
      console.log("Сообщений в чате пока нет");
    } else {
      console.log(`Найдено сообщений: ${messages.length}\n`);
      messages.forEach((item: any) => {
        const formatted = formatMessage(item);
        const pieces = [formatted.time, formatted.author, formatted.text].filter(Boolean);
        if (pieces.length > 0) {
          console.log(pieces.join(" | "));
        }
      });
    }

    console.log("\n✅ Тест успешно завершен! Live Chat ID извлечен и сообщения получены.");
  } catch (error) {
    if (error instanceof Error) {
      console.error("❌ Ошибка:", error.message);
    } else {
      console.error("❌ Неизвестная ошибка:", error);
    }
    process.exit(1);
  }
}

testChannel();
</file>

<file path="src/test-connection.ts">
import dotenv from "dotenv";
import { google } from "googleapis";

dotenv.config();

const apiKey = process.env.YOUTUBE_API_KEY;

if (!apiKey) {
  throw new Error("YOUTUBE_API_KEY отсутствует в окружении");
}

const youtube = google.youtube({ version: "v3", auth: apiKey });

async function testConnection() {
  try {
    console.log("Проверка подключения к YouTube API...");
    console.log("API ключ:", apiKey!.substring(0, 10) + "...");
    
    const response = await youtube.videos.list({
      part: ["snippet"],
      chart: "mostPopular",
      maxResults: 1,
      regionCode: "RU",
    });

    if (response.data.items && response.data.items.length > 0) {
      const video = response.data.items[0];
      console.log("✅ Подключение успешно!");
      console.log("Тестовое видео:", video.snippet?.title);
      console.log("Канал:", video.snippet?.channelTitle);
      console.log("API работает корректно.");
    } else {
      console.log("⚠️ Подключение установлено, но данные не получены.");
    }
  } catch (error) {
    if (error instanceof Error) {
      console.error("❌ Ошибка подключения:", error.message);
      if (error.message.includes("API key")) {
        console.error("Проверьте правильность API ключа.");
      }
    } else {
      console.error("❌ Неизвестная ошибка:", error);
    }
    process.exit(1);
  }
}

testConnection();
</file>

<file path="CLAUDE.md">
# YT-Chat Project

YouTube канал помощник с live chat интеграцией и статистикой.

## Agents

Для фронтенд задач (компоненты, страницы, стили) используй агента `frontend-developer`.

## Stack

- Next.js 14 (App Router)
- PostgreSQL (pg)
- YouTube Data API v3 (googleapis)
- TypeScript

## Structure

```
app/                    # Next.js pages
  api/                  # API routes
    channel-stats/      # Статистика канала
    live-chat-id/       # Получение chat ID трансляции
    messages/           # Сообщения чата (polling, SSE, DB)
    videos/             # Список видео канала
  obs/                  # OBS Browser Source интерфейс
  overview/             # Статистика канала
  transmissions/        # Live chat трансляций
  videos/               # Редактирование видео
components/             # React компоненты
lib/                    # Утилиты
  database.ts           # PostgreSQL подключение и операции
  youtube-api.ts        # YouTube API wrapper
  api-logger.ts         # Логирование API запросов
src/                    # CLI скрипты (legacy)
```

## Environment Variables

```
YOUTUBE_API_KEY         # YouTube Data API v3 key
YOUTUBE_CHANNEL_ID      # ID канала
DB_HOST=localhost       # PostgreSQL host
DB_PORT=5432
DB_NAME=yt_chat
DB_USER=ris             # Роль PostgreSQL (не postgres!)
DB_PASSWORD=
```

## Commands

```bash
npm run dev             # Development server
npm run build           # Production build
npm run test:connection # Тест YouTube API
npm run test:serejaris  # Тест получения chat ID
```

## API Quota

YouTube API имеет дневной лимит квоты. `search.list` стоит 100 единиц — используй кнопку загрузки на /videos вместо автозапросов.

## Database

PostgreSQL с таблицами:
- `chat_messages` — сообщения из live chat
- `api_request_logs` — логи API запросов

Таблицы создаются автоматически при первом подключении (`lib/database.ts:initDatabase`).
</file>

<file path="app/api/channel-stats/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createYoutubeClient, getChannelStats } from "@/lib/youtube-api";

export async function GET(request: NextRequest) {
  const apiKey = process.env.YOUTUBE_API_KEY;
  const channelId = process.env.YOUTUBE_CHANNEL_ID;

  if (!apiKey) {
    return NextResponse.json({ error: "YOUTUBE_API_KEY отсутствует в окружении" }, { status: 500 });
  }

  if (!channelId) {
    return NextResponse.json({ error: "YOUTUBE_CHANNEL_ID отсутствует в окружении" }, { status: 500 });
  }

  try {
    const youtube = createYoutubeClient(apiKey);
    const stats = await getChannelStats(youtube, channelId);
    
    if (!stats) {
      return NextResponse.json({ error: "Канал не найден" }, { status: 404 });
    }
    
    return NextResponse.json(stats);
  } catch (error) {
    const message = error instanceof Error ? error.message : "Неизвестная ошибка";
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
</file>

<file path="app/api/live-chat-id/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createYoutubeClient, getLiveBroadcasts, getLiveChatId } from "@/lib/youtube-api";

export async function GET(request: NextRequest) {
  const apiKey = process.env.YOUTUBE_API_KEY;
  const channelId = process.env.YOUTUBE_CHANNEL_ID;

  if (!apiKey) {
    return NextResponse.json({ error: "YOUTUBE_API_KEY отсутствует в окружении" }, { status: 500 });
  }

  if (!channelId) {
    return NextResponse.json({ error: "YOUTUBE_CHANNEL_ID отсутствует в окружении" }, { status: 500 });
  }

  try {
    const youtube = createYoutubeClient(apiKey);
    const broadcasts = await getLiveBroadcasts(youtube, channelId);
    const liveVideo = broadcasts.find((item) => item.id?.videoId);
    
    if (!liveVideo?.id?.videoId) {
      return NextResponse.json({ error: "Активная трансляция не найдена" }, { status: 404 });
    }
    
    const liveChatId = await getLiveChatId(youtube, liveVideo.id.videoId);
    if (!liveChatId) {
      return NextResponse.json({ error: "Live Chat ID не найден" }, { status: 404 });
    }
    
    return NextResponse.json({
      liveChatId,
      videoId: liveVideo.id.videoId,
      title: liveVideo.snippet?.title ?? "",
      scheduledStartTime: liveVideo.snippet?.publishedAt ?? null,
    });
  } catch (error) {
    const message = error instanceof Error ? error.message : "Неизвестная ошибка";
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
</file>

<file path="app/obs/page.module.css">
.container {
  width: 100%;
  height: 100vh;
  padding: 16px;
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
  background: transparent;
}

.messages {
  list-style: none;
  display: flex;
  flex-direction: column;
  gap: 12px;
  max-height: 100%;
  overflow-y: auto;
}

.message {
  display: flex;
  flex-direction: column;
  gap: 4px;
  padding: 12px 16px;
  background: rgba(0, 0, 0, 0.75);
  border-radius: 8px;
  border-left: 3px solid #38bdf8;
  backdrop-filter: blur(8px);
  animation: slideIn 0.3s ease-out;
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.messageHeader {
  display: flex;
  align-items: center;
  gap: 8px;
}

.messageAuthor {
  font-weight: 600;
  color: #38bdf8;
  font-size: 14px;
}

.messageTime {
  font-size: 12px;
  color: rgba(255, 255, 255, 0.6);
}

.messageText {
  font-size: 14px;
  line-height: 1.5;
  color: #ffffff;
  word-wrap: break-word;
}

.messages::-webkit-scrollbar {
  width: 4px;
}

.messages::-webkit-scrollbar-track {
  background: transparent;
}

.messages::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.2);
  border-radius: 2px;
}

/* Overlay styles */
.overlay {
  position: fixed;
  bottom: 24px;
  left: 24px;
  right: 24px;
  padding: 20px 24px;
  background: rgba(0, 0, 0, 0.85);
  border-radius: 12px;
  border-left: 4px solid #38bdf8;
  backdrop-filter: blur(12px);
  transition: opacity 0.3s ease, transform 0.3s ease;
  z-index: 1000;
}

.overlayVisible {
  opacity: 1;
  transform: translateY(0);
}

.overlayHidden {
  opacity: 0;
  transform: translateY(20px);
}

.overlayAuthor {
  font-weight: 700;
  font-size: 28px;
  color: #38bdf8;
  margin-bottom: 12px;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
}

.overlayText {
  font-size: 32px;
  line-height: 1.4;
  color: #ffffff;
  word-wrap: break-word;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
}

.cursor {
  animation: blink 0.7s infinite;
  color: #38bdf8;
  font-weight: 300;
}

@keyframes blink {
  0%, 50% {
    opacity: 1;
  }
  51%, 100% {
    opacity: 0;
  }
}
</file>

<file path="app/obs/page.tsx">
"use client";

import { useEffect, useState, useRef, useCallback } from "react";
import styles from "./page.module.css";

interface Message {
  time: string;
  author: string;
  text: string;
}

interface OverlayMessage {
  id: string;
  author: string;
  message: string;
  timestamp: number;
}

export default function OBSPage() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [overlayMessage, setOverlayMessage] = useState<OverlayMessage | null>(null);
  const [displayedText, setDisplayedText] = useState("");
  const [isTyping, setIsTyping] = useState(false);
  const [isVisible, setIsVisible] = useState(false);
  const lastOverlayIdRef = useRef<string | null>(null);
  const [isMonitoringEnabled, setIsMonitoringEnabled] = useState(() => {
    if (typeof window !== "undefined") {
      const saved = localStorage.getItem("obsMonitoringEnabled");
      return saved !== null ? saved === "true" : true;
    }
    return true;
  });

  const eventSourceRef = useRef<EventSource | null>(null);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const checkStreamTimerRef = useRef<NodeJS.Timeout | null>(null);
  const retryDelayRef = useRef<number>(5000);
  const isMountedRef = useRef<boolean>(true);
  const abortControllerRef = useRef<AbortController | null>(null);
  const checkForStreamRef = useRef<(() => Promise<void>) | null>(null);

  useEffect(() => {
    if (typeof window !== "undefined") {
      localStorage.setItem("obsMonitoringEnabled", String(isMonitoringEnabled));
    }
  }, [isMonitoringEnabled]);

  // Polling for overlay messages
  useEffect(() => {
    const pollOverlay = async () => {
      try {
        const response = await fetch("/api/overlay");
        if (response.ok) {
          const data = await response.json();
          const newOverlay = data.overlay as OverlayMessage | null;

          if (newOverlay && newOverlay.id !== lastOverlayIdRef.current) {
            lastOverlayIdRef.current = newOverlay.id;
            setOverlayMessage(newOverlay);
            setDisplayedText("");
            setIsTyping(true);
            setIsVisible(true);
          } else if (!newOverlay && lastOverlayIdRef.current) {
            lastOverlayIdRef.current = null;
            setIsVisible(false);
            setTimeout(() => {
              setOverlayMessage(null);
              setDisplayedText("");
            }, 300);
          }
        }
      } catch (error) {
        console.error("Failed to fetch overlay:", error);
      }
    };

    pollOverlay();
    const interval = setInterval(pollOverlay, 1500);
    return () => clearInterval(interval);
  }, []);

  // Typewriter effect
  useEffect(() => {
    if (!overlayMessage || !isTyping) return;

    const text = overlayMessage.message;
    let index = 0;

    const typeInterval = setInterval(() => {
      if (index < text.length) {
        setDisplayedText(text.slice(0, index + 1));
        index++;
      } else {
        setIsTyping(false);
        clearInterval(typeInterval);
      }
    }, 50);

    return () => clearInterval(typeInterval);
  }, [overlayMessage, isTyping]);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const appendMessage = (message: Message) => {
    setMessages((prev) => {
      const updated = [...prev, message];
      const maxMessages = 50;
      return updated.slice(-maxMessages);
    });
  };

  const stopStreaming = useCallback(() => {
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
      eventSourceRef.current = null;
    }
    setMessages([]);
  }, []);

  const startStreaming = useCallback(
    (payload: { liveChatId: string; videoId: string }) => {
      if (!isMountedRef.current || !isMonitoringEnabled || document.hidden) {
        return;
      }

      const { liveChatId, videoId } = payload;

      if (liveChatId && videoId) {
        const url = `/api/messages/stream?liveChatId=${encodeURIComponent(liveChatId)}&videoId=${encodeURIComponent(videoId)}`;
        const eventSource = new EventSource(url);
        eventSourceRef.current = eventSource;

        eventSource.onmessage = (event) => {
          if (!isMountedRef.current) return;
          try {
            const data = JSON.parse(event.data);
            if (data.messages && Array.isArray(data.messages)) {
              data.messages.forEach((msg: Message) => appendMessage(msg));
            }
          } catch (error) {
            console.error("Failed to parse SSE message:", error);
          }
        };

        eventSource.onerror = () => {
          if (!isMountedRef.current) return;
          eventSource.close();
          eventSourceRef.current = null;

          if (isMonitoringEnabled && !document.hidden && isMountedRef.current && checkForStreamRef.current) {
            checkStreamTimerRef.current = setTimeout(() => {
              checkForStreamRef.current?.();
            }, 5000);
          }
        };
      }
    },
    [isMonitoringEnabled]
  );

  const scheduleNextCheck = useCallback(() => {
    if (checkStreamTimerRef.current) {
      clearTimeout(checkStreamTimerRef.current);
      checkStreamTimerRef.current = null;
    }

    if (
      isMonitoringEnabled &&
      !document.hidden &&
      isMountedRef.current &&
      !eventSourceRef.current &&
      checkForStreamRef.current
    ) {
      checkStreamTimerRef.current = setTimeout(() => {
        checkForStreamRef.current?.();
      }, retryDelayRef.current);
    }
  }, [isMonitoringEnabled]);

  const checkForStream = useCallback(async () => {
    if (!isMonitoringEnabled || document.hidden || !isMountedRef.current) {
      return;
    }

    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    abortControllerRef.current = new AbortController();

    try {
      const response = await fetch("/api/live-chat-id", {
        signal: abortControllerRef.current.signal,
      });

      if (!response.ok) {
        throw new Error("live chat id not found");
      }

      const payload = await response.json();
      retryDelayRef.current = 5000;
      startStreaming(payload);
    } catch (error: any) {
      if (error.name === "AbortError") {
        return;
      }

      if (!isMountedRef.current) return;

      retryDelayRef.current = Math.min(retryDelayRef.current * 2, 30000);
      scheduleNextCheck();
    }
  }, [isMonitoringEnabled, startStreaming, scheduleNextCheck]);

  useEffect(() => {
    checkForStreamRef.current = checkForStream;
  }, [checkForStream]);

  useEffect(() => {
    isMountedRef.current = true;

    if (isMonitoringEnabled && checkForStreamRef.current) {
      checkForStreamRef.current();
    }

    return () => {
      isMountedRef.current = false;
      if (eventSourceRef.current) {
        eventSourceRef.current.close();
        eventSourceRef.current = null;
      }
      if (checkStreamTimerRef.current) {
        clearTimeout(checkStreamTimerRef.current);
        checkStreamTimerRef.current = null;
      }
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
        abortControllerRef.current = null;
      }
    };
  }, [isMonitoringEnabled]);

  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.hidden) {
        if (eventSourceRef.current) {
          eventSourceRef.current.close();
          eventSourceRef.current = null;
        }
        if (checkStreamTimerRef.current) {
          clearTimeout(checkStreamTimerRef.current);
          checkStreamTimerRef.current = null;
        }
        if (abortControllerRef.current) {
          abortControllerRef.current.abort();
          abortControllerRef.current = null;
        }
      } else if (isMonitoringEnabled && isMountedRef.current && checkForStreamRef.current) {
        retryDelayRef.current = 5000;
        checkForStreamRef.current();
      }
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);
    return () => {
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, [isMonitoringEnabled]);

  return (
    <div className={styles.container}>
      {overlayMessage && (
        <div className={`${styles.overlay} ${isVisible ? styles.overlayVisible : styles.overlayHidden}`}>
          <div className={styles.overlayAuthor}>{overlayMessage.author}</div>
          <div className={styles.overlayText}>
            {displayedText}
            {isTyping && <span className={styles.cursor}>|</span>}
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/overview/page.module.css">
.layout {
  width: min(960px, 100%);
  min-height: 100vh;
  margin: 0 auto;
  display: grid;
  grid-template-rows: auto 1fr;
  background: rgba(15, 23, 42, 0.85);
  border-radius: 16px;
  border: 1px solid rgba(148, 163, 184, 0.2);
  overflow: hidden;
  backdrop-filter: blur(16px);
}

.content {
  padding: 32px 24px;
}

.title {
  font-size: 28px;
  font-weight: 600;
  margin-bottom: 32px;
  color: var(--text);
}

.loading,
.error {
  padding: 24px;
  text-align: center;
  color: var(--text-muted);
}

.error {
  color: var(--error);
}

.stats {
  display: flex;
  flex-direction: column;
  gap: 32px;
}

.channelInfo {
  padding: 24px;
  background: rgba(30, 41, 59, 0.85);
  border-radius: 12px;
  border: 1px solid rgba(56, 189, 248, 0.1);
}

.channelTitle {
  font-size: 24px;
  font-weight: 600;
  color: var(--accent);
  margin-bottom: 12px;
}

.channelDescription {
  color: var(--text-muted);
  line-height: 1.6;
}

.metrics {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 20px;
}

.metric {
  padding: 24px;
  background: rgba(30, 41, 59, 0.85);
  border-radius: 12px;
  border: 1px solid rgba(56, 189, 248, 0.1);
  text-align: center;
}

.metricValue {
  font-size: 32px;
  font-weight: 700;
  color: var(--accent);
  margin-bottom: 8px;
}

.metricLabel {
  font-size: 14px;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

@media (max-width: 640px) {
  .layout {
    border-radius: 0;
    min-height: 100vh;
  }

  .content {
    padding: 24px 16px;
  }

  .metrics {
    grid-template-columns: 1fr;
  }
}
</file>

<file path="app/overview/page.tsx">
"use client";

import { useEffect, useState } from "react";
import Navigation from "@/components/Navigation";
import styles from "./page.module.css";

interface ChannelStats {
  title: string;
  description: string;
  subscriberCount: string;
  videoCount: string;
  viewCount: string;
}

export default function OverviewPage() {
  const [stats, setStats] = useState<ChannelStats | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchStats = async () => {
      try {
        setLoading(true);
        const response = await fetch("/api/channel-stats");
        if (!response.ok) {
          throw new Error("Не удалось загрузить статистику");
        }
        const data = await response.json();
        setStats(data);
        setError(null);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Неизвестная ошибка");
      } finally {
        setLoading(false);
      }
    };

    fetchStats();
  }, []);

  const formatNumber = (num: string) => {
    const number = parseInt(num, 10);
    if (number >= 1000000) {
      return (number / 1000000).toFixed(1) + "M";
    }
    if (number >= 1000) {
      return (number / 1000).toFixed(1) + "K";
    }
    return number.toLocaleString("ru-RU");
  };

  return (
    <div className={styles.layout}>
      <Navigation />
      <main className={styles.content}>
        <h1 className={styles.title}>Обзор канала</h1>
        
        {loading && <div className={styles.loading}>Загрузка...</div>}
        
        {error && <div className={styles.error}>{error}</div>}
        
        {stats && (
          <div className={styles.stats}>
            <div className={styles.channelInfo}>
              <h2 className={styles.channelTitle}>{stats.title}</h2>
              {stats.description && (
                <p className={styles.channelDescription}>{stats.description}</p>
              )}
            </div>
            
            <div className={styles.metrics}>
              <div className={styles.metric}>
                <div className={styles.metricValue}>{formatNumber(stats.subscriberCount)}</div>
                <div className={styles.metricLabel}>Подписчиков</div>
              </div>
              
              <div className={styles.metric}>
                <div className={styles.metricValue}>{formatNumber(stats.viewCount)}</div>
                <div className={styles.metricLabel}>Просмотров</div>
              </div>
              
              <div className={styles.metric}>
                <div className={styles.metricValue}>{formatNumber(stats.videoCount)}</div>
                <div className={styles.metricLabel}>Видео</div>
              </div>
            </div>
          </div>
        )}
      </main>
    </div>
  );
}
</file>

<file path="app/transmissions/page.module.css">
.layout {
  width: min(960px, 100%);
  min-height: 100vh;
  margin: 0 auto;
  display: grid;
  grid-template-rows: auto auto 1fr auto;
  background: rgba(15, 23, 42, 0.85);
  border-radius: 16px;
  border: 1px solid rgba(148, 163, 184, 0.2);
  overflow: hidden;
  backdrop-filter: blur(16px);
}

.header,
.footer {
  padding: 20px 24px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: rgba(30, 41, 59, 0.8);
}

.streamInfo {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.streamStatus {
  font-size: 14px;
  color: var(--text-muted);
}

.streamTitle {
  font-size: 20px;
  font-weight: 600;
  color: var(--text);
}

.controls {
  display: flex;
  gap: 12px;
}

.controls button {
  background: var(--accent);
  color: #0b1120;
  border: none;
  padding: 10px 16px;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

.controls button:active {
  transform: scale(0.97);
}

.controls button:focus-visible {
  outline: 2px solid rgba(56, 189, 248, 0.6);
  outline-offset: 2px;
}

.monitoringActive {
  background: var(--accent) !important;
}

.monitoringInactive {
  background: rgba(148, 163, 184, 0.3) !important;
  color: var(--text-muted) !important;
}

.overlayPanel {
  padding: 12px 24px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: rgba(30, 41, 59, 0.6);
  border-bottom: 1px solid rgba(148, 163, 184, 0.1);
}

.overlayStatus {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
}

.overlayActive {
  color: var(--accent);
}

.overlayAuthor {
  color: var(--text);
  font-weight: 600;
}

.overlayEmpty {
  color: var(--text-muted);
}

.clearOverlayBtn {
  background: rgba(239, 68, 68, 0.2);
  color: #ef4444;
  border: 1px solid rgba(239, 68, 68, 0.3);
  padding: 6px 12px;
  border-radius: 6px;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.15s ease;
}

.clearOverlayBtn:hover {
  background: rgba(239, 68, 68, 0.3);
}

.content {
  padding: 24px;
  overflow-y: auto;
}

.messages {
  list-style: none;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.message {
  display: grid;
  grid-template-columns: auto 1fr auto;
  gap: 6px 12px;
  padding: 16px;
  background: rgba(30, 41, 59, 0.85);
  border-radius: 12px;
  border: 1px solid rgba(56, 189, 248, 0.1);
  box-shadow: 0 12px 32px rgba(15, 23, 42, 0.3);
  transition: border-color 0.2s ease;
}

.messageActive {
  border-color: var(--accent);
  background: rgba(56, 189, 248, 0.1);
}

.overlayBtn {
  background: transparent;
  border: none;
  font-size: 18px;
  cursor: pointer;
  opacity: 0.4;
  transition: opacity 0.15s ease, transform 0.15s ease;
  padding: 4px;
  grid-row: 1 / 2;
}

.overlayBtn:hover {
  opacity: 1;
  transform: scale(1.1);
}

.messageActive .overlayBtn {
  opacity: 1;
}

.message time {
  font-size: 13px;
  color: var(--text-muted);
}

.message strong {
  font-size: 15px;
  color: var(--accent);
}

.message p {
  grid-column: 1 / -1;
  white-space: pre-wrap;
  line-height: 1.55;
}

.footer {
  font-size: 14px;
  color: var(--text-muted);
}

.footerStatus {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.errorDetails {
  font-size: 12px;
  color: var(--error);
  opacity: 0.8;
  max-width: 600px;
  word-break: break-word;
}

.statusError {
  color: var(--error);
}

.apiIndicator {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 12px;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.apiDot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: rgba(148, 163, 184, 0.3);
  transition: all 0.2s ease;
}

.apiActive {
  background: var(--accent);
  box-shadow: 0 0 8px var(--accent);
  animation: pulse 1s ease-out;
}

@keyframes pulse {
  0% {
    transform: scale(1);
    opacity: 1;
  }
  50% {
    transform: scale(1.3);
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

@media (max-width: 640px) {
  .layout {
    border-radius: 0;
    min-height: 100vh;
  }

  .header,
  .footer {
    flex-direction: column;
    align-items: flex-start;
    gap: 12px;
  }

  .controls button {
    width: 100%;
  }
}
</file>

<file path="app/transmissions/page.tsx">
"use client";

import { useEffect, useState, useRef, useCallback } from "react";
import Navigation from "@/components/Navigation";
import styles from "./page.module.css";
import { logEmitter } from "@/lib/api-logger-client";

interface Message {
  time: string;
  author: string;
  text: string;
}

interface OverlayMessage {
  id: string;
  author: string;
  message: string;
  timestamp: number;
}

export default function TransmissionsPage() {
  const [liveChatId, setLiveChatId] = useState<string | null>(null);
  const [videoId, setVideoId] = useState<string | null>(null);
  const [streamTitle, setStreamTitle] = useState("");
  const [streamStatus, setStreamStatus] = useState("Поиск трансляции...");
  const [pollingStatus, setPollingStatus] = useState("Ожидание...");
  const [messages, setMessages] = useState<Message[]>([]);
  const [isError, setIsError] = useState(false);
  const [pollingError, setPollingError] = useState(false);
  const [isMonitoringEnabled, setIsMonitoringEnabled] = useState(() => {
    if (typeof window !== "undefined") {
      const saved = localStorage.getItem("monitoringEnabled");
      return saved !== null ? saved === "true" : true;
    }
    return true;
  });
  const [apiActivity, setApiActivity] = useState(false);
  const [errorDetails, setErrorDetails] = useState<string | null>(null);
  const [overlayMessage, setOverlayMessage] = useState<OverlayMessage | null>(null);
  const [activeMessageIndex, setActiveMessageIndex] = useState<number | null>(null);

  const eventSourceRef = useRef<EventSource | null>(null);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const checkStreamTimerRef = useRef<NodeJS.Timeout | null>(null);
  const retryDelayRef = useRef<number>(5000);
  const isMountedRef = useRef<boolean>(true);
  const abortControllerRef = useRef<AbortController | null>(null);
  const checkForStreamRef = useRef<(() => Promise<void>) | null>(null);

  useEffect(() => {
    if (typeof window !== "undefined") {
      localStorage.setItem("monitoringEnabled", String(isMonitoringEnabled));
    }
  }, [isMonitoringEnabled]);

  // Listen for API activity
  useEffect(() => {
    const handleApiLog = () => {
      setApiActivity(true);
      setTimeout(() => setApiActivity(false), 1000);
    };

    logEmitter.on("newLog", handleApiLog);
    return () => {
      logEmitter.off("newLog", handleApiLog);
    };
  }, []);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const stopStreaming = useCallback(() => {
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
      eventSourceRef.current = null;
    }
    setLiveChatId(null);
    setVideoId(null);
    setStreamTitle("");
    setMessages([]);
  }, []);

  const startStreaming = useCallback(
    (payload: { liveChatId: string; videoId: string; title?: string }) => {
      if (!isMountedRef.current || !isMonitoringEnabled || document.hidden) {
        return;
      }

      const chatId = payload.liveChatId;
      const vidId = payload.videoId;

      setLiveChatId(chatId);
      setVideoId(vidId);
      setStreamTitle(payload.title ?? "");
      setStreamStatus("Чат подключен");
      setPollingStatus("Получение сообщений...");
      setPollingError(false);
      setIsError(false);
      setErrorDetails(null);

      if (chatId && vidId) {
        const url = `/api/messages/stream?liveChatId=${encodeURIComponent(chatId)}&videoId=${encodeURIComponent(vidId)}`;
        const eventSource = new EventSource(url);
        eventSourceRef.current = eventSource;

        eventSource.onmessage = (event) => {
          if (!isMountedRef.current) return;
          try {
            const data = JSON.parse(event.data);
            if (data.messages && Array.isArray(data.messages)) {
              setMessages((prev) => [...prev, ...data.messages]);
              setPollingStatus(
                "Последнее обновление: " +
                  new Date().toLocaleTimeString("ru-RU", { hour12: false })
              );
              setPollingError(false);
              setErrorDetails(null);
            }
            if (data.error) {
              setPollingStatus("Ошибка получения сообщений");
              setPollingError(true);
              setErrorDetails(data.error);
            }
          } catch (error) {
            console.error("Failed to parse SSE message:", error);
          }
        };

        eventSource.onerror = () => {
          if (!isMountedRef.current) return;
          setPollingStatus("Ошибка подключения");
          setPollingError(true);
          eventSource.close();
          eventSourceRef.current = null;

          if (isMonitoringEnabled && !document.hidden && isMountedRef.current && checkForStreamRef.current) {
            checkStreamTimerRef.current = setTimeout(() => {
              checkForStreamRef.current?.();
            }, 5000);
          }
        };
      }
    },
    [isMonitoringEnabled]
  );

  const scheduleNextCheck = useCallback(() => {
    if (checkStreamTimerRef.current) {
      clearTimeout(checkStreamTimerRef.current);
      checkStreamTimerRef.current = null;
    }

    if (
      isMonitoringEnabled &&
      !document.hidden &&
      isMountedRef.current &&
      !eventSourceRef.current &&
      checkForStreamRef.current
    ) {
      checkStreamTimerRef.current = setTimeout(() => {
        checkForStreamRef.current?.();
      }, retryDelayRef.current);
    }
  }, [isMonitoringEnabled]);

  const checkForStream = useCallback(async () => {
    if (!isMonitoringEnabled || document.hidden || !isMountedRef.current) {
      return;
    }

    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    abortControllerRef.current = new AbortController();

    try {
      setStreamStatus("Поиск трансляции...");
      setPollingStatus("Проверка...");
      setIsError(false);
      setErrorDetails(null);

      const response = await fetch("/api/live-chat-id", {
        signal: abortControllerRef.current.signal,
      });

      const payload = await response.json();

      if (!response.ok) {
        throw new Error(payload.error || "live chat id not found");
      }

      retryDelayRef.current = 5000;
      startStreaming(payload);
    } catch (error: any) {
      if (error.name === "AbortError") {
        return;
      }

      if (!isMountedRef.current) return;

      const errorMessage = error.message || "Неизвестная ошибка";
      setStreamStatus("Нет активной трансляции");
      setPollingStatus("Ожидание трансляции");
      setIsError(true);
      setPollingError(true);
      setErrorDetails(errorMessage);

      retryDelayRef.current = Math.min(retryDelayRef.current * 2, 30000);
      scheduleNextCheck();
    }
  }, [isMonitoringEnabled, startStreaming, scheduleNextCheck]);

  useEffect(() => {
    checkForStreamRef.current = checkForStream;
  }, [checkForStream]);

  const showInOverlay = useCallback(async (message: Message, index: number) => {
    try {
      const response = await fetch("/api/overlay", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          id: `${index}-${Date.now()}`,
          author: message.author,
          message: message.text,
        }),
      });
      if (response.ok) {
        const data = await response.json();
        setOverlayMessage(data.overlay);
        setActiveMessageIndex(index);
      }
    } catch (error) {
      console.error("Failed to show in overlay:", error);
    }
  }, []);

  const clearOverlay = useCallback(async () => {
    try {
      const response = await fetch("/api/overlay", { method: "DELETE" });
      if (response.ok) {
        setOverlayMessage(null);
        setActiveMessageIndex(null);
      }
    } catch (error) {
      console.error("Failed to clear overlay:", error);
    }
  }, []);

  const toggleMonitoring = useCallback(() => {
    const newValue = !isMonitoringEnabled;
    setIsMonitoringEnabled(newValue);

    if (!newValue) {
      stopStreaming();
      if (checkStreamTimerRef.current) {
        clearTimeout(checkStreamTimerRef.current);
        checkStreamTimerRef.current = null;
      }
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
        abortControllerRef.current = null;
      }
      setStreamStatus("Мониторинг выключен");
      setPollingStatus("Ожидание...");
    } else {
      retryDelayRef.current = 5000;
      if (checkForStreamRef.current) {
        checkForStreamRef.current();
      }
    }
  }, [isMonitoringEnabled, stopStreaming]);

  useEffect(() => {
    isMountedRef.current = true;

    if (isMonitoringEnabled && checkForStreamRef.current) {
      checkForStreamRef.current();
    }

    return () => {
      isMountedRef.current = false;
      if (eventSourceRef.current) {
        eventSourceRef.current.close();
        eventSourceRef.current = null;
      }
      if (checkStreamTimerRef.current) {
        clearTimeout(checkStreamTimerRef.current);
        checkStreamTimerRef.current = null;
      }
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
        abortControllerRef.current = null;
      }
    };
  }, [isMonitoringEnabled]);

  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.hidden) {
        if (eventSourceRef.current) {
          eventSourceRef.current.close();
          eventSourceRef.current = null;
        }
        if (checkStreamTimerRef.current) {
          clearTimeout(checkStreamTimerRef.current);
          checkStreamTimerRef.current = null;
        }
        if (abortControllerRef.current) {
          abortControllerRef.current.abort();
          abortControllerRef.current = null;
        }
      } else if (isMonitoringEnabled && isMountedRef.current && checkForStreamRef.current) {
        retryDelayRef.current = 5000;
        checkForStreamRef.current();
      }
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);
    return () => {
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, [isMonitoringEnabled, checkForStream]);

  return (
    <div className={styles.layout}>
      <Navigation />
      <header className={styles.header}>
        <div className={styles.streamInfo}>
          <span className={`${styles.streamStatus} ${isError ? styles.statusError : ""}`}>
            {streamStatus}
          </span>
          <h1 className={styles.streamTitle}>{streamTitle}</h1>
        </div>
        <div className={styles.controls}>
          <button
            onClick={toggleMonitoring}
            type="button"
            className={isMonitoringEnabled ? styles.monitoringActive : styles.monitoringInactive}
          >
            {isMonitoringEnabled ? "Выключить мониторинг" : "Включить мониторинг"}
          </button>
          <button onClick={() => checkForStreamRef.current?.()} type="button">
            Обновить
          </button>
        </div>
      </header>
      <div className={styles.overlayPanel}>
        <div className={styles.overlayStatus}>
          {overlayMessage ? (
            <>
              <span className={styles.overlayActive}>В оверлее:</span>
              <span className={styles.overlayAuthor}>{overlayMessage.author}</span>
            </>
          ) : (
            <span className={styles.overlayEmpty}>Оверлей пуст</span>
          )}
        </div>
        {overlayMessage && (
          <button onClick={clearOverlay} className={styles.clearOverlayBtn} type="button">
            Убрать из оверлея
          </button>
        )}
      </div>
      <main className={styles.content}>
        <ul className={styles.messages}>
          {messages.map((message, index) => (
            <li key={index} className={`${styles.message} ${activeMessageIndex === index ? styles.messageActive : ""}`}>
              <time>{message.time}</time>
              <strong>{message.author}</strong>
              <button
                onClick={() => showInOverlay(message, index)}
                className={styles.overlayBtn}
                type="button"
                title="Показать в оверлее"
              >
                📺
              </button>
              <p>{message.text}</p>
            </li>
          ))}
          <div ref={messagesEndRef} />
        </ul>
      </main>
      <footer className={styles.footer}>
        <div className={styles.footerStatus}>
          <span className={pollingError ? styles.statusError : ""}>{pollingStatus}</span>
          {errorDetails && (
            <span className={styles.errorDetails}>{errorDetails}</span>
          )}
        </div>
        <span className={styles.apiIndicator}>
          <span className={`${styles.apiDot} ${apiActivity ? styles.apiActive : ""}`} />
          API
        </span>
      </footer>
    </div>
  );
}
</file>

<file path="app/globals.css">
:root {
  color-scheme: dark light;
  --bg: #0f172a;
  --panel: #1e293b;
  --accent: #38bdf8;
  --text: #e2e8f0;
  --text-muted: #94a3b8;
  --error: #f87171;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
}
</file>

<file path="app/layout.tsx">
import type { Metadata } from "next";
import "./globals.css";
import Navigation from "@/components/Navigation";

export const metadata: Metadata = {
  title: "YouTube Live Chat",
  description: "Помощник по YouTube каналу",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="ru">
      <body>{children}</body>
    </html>
  );
}
</file>

<file path="app/page.tsx">
import { redirect } from "next/navigation";

export default function HomePage() {
  redirect("/transmissions");
}
</file>

<file path="components/Navigation.module.css">
.nav {
  display: flex;
  gap: 8px;
  padding: 16px 24px;
  background: rgba(30, 41, 59, 0.8);
  border-bottom: 1px solid rgba(148, 163, 184, 0.2);
}

.link {
  padding: 8px 16px;
  color: var(--text-muted);
  text-decoration: none;
  border-radius: 8px;
  transition: all 0.2s ease;
  font-weight: 500;
}

.link:hover {
  background: rgba(56, 189, 248, 0.1);
  color: var(--accent);
}

.link.active {
  background: var(--accent);
  color: #0b1120;
}
</file>

<file path="lib/database.ts">
import { Pool } from "pg";

const pool = new Pool({
  host: process.env.DB_HOST || "localhost",
  port: Number(process.env.DB_PORT || 5432),
  database: process.env.DB_NAME || "yt_chat",
  user: process.env.DB_USER || "postgres",
  password: process.env.DB_PASSWORD || "",
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});

export async function initDatabase() {
  const client = await pool.connect();
  try {
    await client.query(`
      CREATE TABLE IF NOT EXISTS chat_messages (
        id SERIAL PRIMARY KEY,
        message_id VARCHAR(255) UNIQUE NOT NULL,
        video_id VARCHAR(255),
        live_chat_id VARCHAR(255),
        author_name VARCHAR(255) NOT NULL,
        message_text TEXT NOT NULL,
        published_at TIMESTAMP NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
      
      CREATE INDEX IF NOT EXISTS idx_message_id ON chat_messages(message_id);
      CREATE INDEX IF NOT EXISTS idx_video_id ON chat_messages(video_id);
      CREATE INDEX IF NOT EXISTS idx_published_at ON chat_messages(published_at DESC);
      
      CREATE TABLE IF NOT EXISTS api_request_logs (
        id SERIAL PRIMARY KEY,
        timestamp TIMESTAMPTZ DEFAULT NOW(),
        endpoint_type VARCHAR(100) NOT NULL,
        method_name VARCHAR(100) NOT NULL,
        request_params JSONB,
        status VARCHAR(20) NOT NULL,
        error_message TEXT,
        quota_cost INTEGER NOT NULL,
        response_time_ms INTEGER NOT NULL
      );
      
      CREATE INDEX IF NOT EXISTS idx_api_logs_timestamp ON api_request_logs(timestamp DESC);
      CREATE INDEX IF NOT EXISTS idx_api_logs_endpoint_type ON api_request_logs(endpoint_type);
      CREATE INDEX IF NOT EXISTS idx_api_logs_status ON api_request_logs(status);
    `);
  } finally {
    client.release();
  }
}

export interface ChatMessage {
  messageId: string;
  videoId?: string;
  liveChatId?: string;
  authorName: string;
  messageText: string;
  publishedAt: Date;
}

export async function saveMessage(message: ChatMessage): Promise<void> {
  const client = await pool.connect();
  try {
    await client.query(
      `INSERT INTO chat_messages (message_id, video_id, live_chat_id, author_name, message_text, published_at)
       VALUES ($1, $2, $3, $4, $5, $6)
       ON CONFLICT (message_id) DO NOTHING`,
      [
        message.messageId,
        message.videoId || null,
        message.liveChatId || null,
        message.authorName,
        message.messageText,
        message.publishedAt,
      ]
    );
  } finally {
    client.release();
  }
}

export async function saveMessages(messages: ChatMessage[]): Promise<void> {
  if (messages.length === 0) return;
  
  const client = await pool.connect();
  try {
    await client.query("BEGIN");
    for (const message of messages) {
      await client.query(
        `INSERT INTO chat_messages (message_id, video_id, live_chat_id, author_name, message_text, published_at)
         VALUES ($1, $2, $3, $4, $5, $6)
         ON CONFLICT (message_id) DO NOTHING`,
        [
          message.messageId,
          message.videoId || null,
          message.liveChatId || null,
          message.authorName,
          message.messageText,
          message.publishedAt,
        ]
      );
    }
    await client.query("COMMIT");
  } catch (error) {
    await client.query("ROLLBACK");
    throw error;
  } finally {
    client.release();
  }
}

export async function getMessages(
  limit: number = 100,
  offset: number = 0,
  videoId?: string
): Promise<ChatMessage[]> {
  const client = await pool.connect();
  try {
    let query = `
      SELECT message_id, video_id, live_chat_id, author_name, message_text, published_at
      FROM chat_messages
    `;
    const params: any[] = [];
    
    if (videoId) {
      query += ` WHERE video_id = $1`;
      params.push(videoId);
    }
    
    query += ` ORDER BY published_at DESC LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
    params.push(limit, offset);
    
    const result = await client.query(query, params);
    return result.rows.map((row) => ({
      messageId: row.message_id,
      videoId: row.video_id,
      liveChatId: row.live_chat_id,
      authorName: row.author_name,
      messageText: row.message_text,
      publishedAt: row.published_at,
    }));
  } finally {
    client.release();
  }
}

export async function closeDatabase(): Promise<void> {
  await pool.end();
}
</file>

<file path="lib/db-init.ts">
import { initDatabase } from "@/lib/database";

let dbInitialized = false;

export async function ensureDatabaseInitialized() {
  if (!dbInitialized) {
    try {
      await initDatabase();
      dbInitialized = true;
    } catch (error) {
      console.error("Ошибка инициализации базы данных:", error);
    }
  }
}
</file>

<file path="lib/youtube-api.ts">
import { google, youtube_v3 } from "googleapis";
import { logApiRequest } from "./api-logger";

export function createYoutubeClient(apiKey: string) {
  return google.youtube({ version: "v3", auth: apiKey });
}

export async function getLiveBroadcasts(youtube: youtube_v3.Youtube, channelId: string) {
  const startTime = Date.now();
  try {
    const response = await youtube.search.list({
      part: ["snippet"],
      channelId,
      type: ["video"],
      eventType: "live",
      maxResults: 10,
    } as any);
    const responseTime = Date.now() - startTime;
    await logApiRequest(
      "getLiveBroadcasts",
      "search.list",
      { channelId, eventType: "live", maxResults: 10 },
      "success",
      responseTime
    );
    return response.data?.items ?? [];
  } catch (error) {
    const responseTime = Date.now() - startTime;
    await logApiRequest(
      "getLiveBroadcasts",
      "search.list",
      { channelId, eventType: "live", maxResults: 10 },
      "error",
      responseTime,
      error instanceof Error ? error.message : "Unknown error"
    );
    throw error;
  }
}

export async function getLiveChatId(youtube: youtube_v3.Youtube, videoId: string) {
  const startTime = Date.now();
  try {
    const response = await youtube.videos.list({
      part: ["liveStreamingDetails"],
      id: [videoId],
    });
    const responseTime = Date.now() - startTime;
    await logApiRequest(
      "getLiveChatId",
      "videos.list",
      { videoId },
      "success",
      responseTime
    );
    return response.data.items?.[0]?.liveStreamingDetails?.activeLiveChatId ?? null;
  } catch (error) {
    const responseTime = Date.now() - startTime;
    await logApiRequest(
      "getLiveChatId",
      "videos.list",
      { videoId },
      "error",
      responseTime,
      error instanceof Error ? error.message : "Unknown error"
    );
    throw error;
  }
}

export async function fetchMessages(
  youtube: youtube_v3.Youtube,
  liveChatId: string,
  pageToken?: string
) {
  const startTime = Date.now();
  try {
    const response = await youtube.liveChatMessages.list({
      liveChatId,
      part: ["id", "snippet", "authorDetails"],
      pageToken,
    });
    const responseTime = Date.now() - startTime;
    await logApiRequest(
      "fetchMessages",
      "liveChatMessages.list",
      { liveChatId, hasPageToken: !!pageToken },
      "success",
      responseTime
    );
    return response.data;
  } catch (error) {
    const responseTime = Date.now() - startTime;
    await logApiRequest(
      "fetchMessages",
      "liveChatMessages.list",
      { liveChatId, hasPageToken: !!pageToken },
      "error",
      responseTime,
      error instanceof Error ? error.message : "Unknown error"
    );
    throw error;
  }
}

export function formatMessage(item: youtube_v3.Schema$LiveChatMessage) {
  const time = item.snippet?.publishedAt
    ? new Date(item.snippet.publishedAt).toLocaleTimeString("ru-RU", { hour12: false })
    : "";
  const author = item.authorDetails?.displayName ?? "Неизвестный автор";
  const text = item.snippet?.displayMessage ?? "";
  const messageId = item.id ?? "";
  const publishedAt = item.snippet?.publishedAt ? new Date(item.snippet.publishedAt) : new Date();
  return { time, author, text, messageId, publishedAt };
}

export async function getChannelStats(youtube: youtube_v3.Youtube, channelId: string) {
  const startTime = Date.now();
  try {
    const response = await youtube.channels.list({
      part: ["snippet", "statistics"],
      id: [channelId],
    });
    
    const responseTime = Date.now() - startTime;
    await logApiRequest(
      "getChannelStats",
      "channels.list",
      { channelId },
      "success",
      responseTime
    );
    
    const channel = response.data.items?.[0];
    if (!channel) {
      return null;
    }
    
    return {
      title: channel.snippet?.title ?? "",
      description: channel.snippet?.description ?? "",
      subscriberCount: channel.statistics?.subscriberCount ?? "0",
      videoCount: channel.statistics?.videoCount ?? "0",
      viewCount: channel.statistics?.viewCount ?? "0",
    };
  } catch (error) {
    const responseTime = Date.now() - startTime;
    await logApiRequest(
      "getChannelStats",
      "channels.list",
      { channelId },
      "error",
      responseTime,
      error instanceof Error ? error.message : "Unknown error"
    );
    throw error;
  }
}

export async function getChannelVideos(youtube: youtube_v3.Youtube, channelId: string, maxResults: number = 50) {
  const startTime = Date.now();
  try {
    const response = await youtube.search.list({
      part: ["snippet"],
      channelId,
      type: ["video"],
      order: "date",
      maxResults,
    } as any);
    const responseTime = Date.now() - startTime;
    await logApiRequest(
      "getChannelVideos",
      "search.list",
      { channelId, maxResults },
      "success",
      responseTime
    );
    return response.data?.items ?? [];
  } catch (error) {
    const responseTime = Date.now() - startTime;
    await logApiRequest(
      "getChannelVideos",
      "search.list",
      { channelId, maxResults },
      "error",
      responseTime,
      error instanceof Error ? error.message : "Unknown error"
    );
    throw error;
  }
}

export async function getVideosDetails(youtube: youtube_v3.Youtube, videoIds: string[]) {
  if (videoIds.length === 0) return [];
  
  const startTime = Date.now();
  try {
    const response = await youtube.videos.list({
      part: ["snippet"],
      id: videoIds,
    });
    const responseTime = Date.now() - startTime;
    await logApiRequest(
      "getVideosDetails",
      "videos.list",
      { videoCount: videoIds.length },
      "success",
      responseTime
    );
    return response.data?.items ?? [];
  } catch (error) {
    const responseTime = Date.now() - startTime;
    await logApiRequest(
      "getVideosDetails",
      "videos.list",
      { videoCount: videoIds.length },
      "error",
      responseTime,
      error instanceof Error ? error.message : "Unknown error"
    );
    throw error;
  }
}

export async function getChannelVideosWithDetails(youtube: youtube_v3.Youtube, channelId: string, maxResults: number = 50) {
  const searchResults = await getChannelVideos(youtube, channelId, maxResults);
  
  if (searchResults.length === 0) {
    return [];
  }
  
  const videoIds = searchResults
    .map((item) => item.id?.videoId)
    .filter((id): id is string => !!id);
  
  if (videoIds.length === 0) {
    return [];
  }
  
  const videosDetails = await getVideosDetails(youtube, videoIds);
  
  return videosDetails.map((video) => ({
    id: video.id ?? "",
    title: video.snippet?.title ?? "",
    description: video.snippet?.description ?? "",
    publishedAt: video.snippet?.publishedAt ?? "",
    thumbnail: video.snippet?.thumbnails?.high?.url ?? video.snippet?.thumbnails?.default?.url ?? "",
    channelId: video.snippet?.channelId ?? "",
    channelTitle: video.snippet?.channelTitle ?? "",
  }));
}
</file>

<file path="src/utils/youtube-api.ts">
import { google, youtube_v3 } from "googleapis";

export function createYoutubeClient(apiKey: string) {
  return google.youtube({ version: "v3", auth: apiKey });
}

export async function getLiveBroadcasts(youtube: youtube_v3.Youtube, channelId: string) {
  const response = await youtube.search.list({
    part: ["snippet"],
    channelId,
    type: ["video"],
    eventType: "live",
    maxResults: 10,
  } as any);
  return response.data?.items ?? [];
}

export async function getLiveChatId(youtube: youtube_v3.Youtube, videoId: string) {
  const response = await youtube.videos.list({
    part: ["liveStreamingDetails"],
    id: [videoId],
  });
  return response.data.items?.[0]?.liveStreamingDetails?.activeLiveChatId ?? null;
}

export async function fetchMessages(
  youtube: youtube_v3.Youtube,
  liveChatId: string,
  pageToken?: string
) {
  const response = await youtube.liveChatMessages.list({
    liveChatId,
    part: ["id", "snippet", "authorDetails"],
    pageToken,
  });
  return response.data;
}

export function formatMessage(item: youtube_v3.Schema$LiveChatMessage) {
  const time = item.snippet?.publishedAt
    ? new Date(item.snippet.publishedAt).toLocaleTimeString("ru-RU", { hour12: false })
    : "";
  const author = item.authorDetails?.displayName ?? "Неизвестный автор";
  const text = item.snippet?.displayMessage ?? "";
  const messageId = item.id ?? "";
  const publishedAt = item.snippet?.publishedAt ? new Date(item.snippet.publishedAt) : new Date();
  return { time, author, text, messageId, publishedAt };
}
</file>

<file path=".env.example">
YOUTUBE_API_KEY=YOUR_YOUTUBE_API_KEY
YOUTUBE_LIVE_CHAT_ID=YOUR_LIVE_CHAT_ID
YOUTUBE_CHANNEL_ID=YOUR_CHANNEL_ID
YOUTUBE_CHANNEL_USERNAME=YOUR_CHANNEL_USERNAME
YOUTUBE_CHANNEL_HANDLE=@serejaris

DB_HOST=localhost
DB_PORT=5432
DB_NAME=yt_chat
DB_USER=ris
DB_PASSWORD=
</file>

<file path=".gitignore">
# Зависимости
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Переменные окружения
.env
.env.local
.env.*.local

# Next.js
.next/
out/
next-env.d.ts

# Скомпилированные файлы
dist/
build/
*.js.map
*.d.ts
*.tsbuildinfo

# IDE и редакторы
.vscode/
.idea/
*.swp
*.swo
*~
.DS_Store

# Логи
logs/
*.log

# Временные файлы
tmp/
temp/
*.tmp

# Кэш
.cache/
.parcel-cache/
.eslintcache

# Тестовое покрытие
coverage/
.nyc_output/
</file>

<file path="next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
}

module.exports = nextConfig
</file>

<file path="package.json">
{
  "name": "yt-chat",
  "version": "1.0.0",
  "description": "YouTube Live Chat помощник с статистикой канала",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test:connection": "ts-node src/test-connection.ts",
    "get-channel": "ts-node src/get-channel-data.ts",
    "test:serejaris": "ts-node src/test-channel-serejaris.ts"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@types/pg": "^8.15.6",
    "googleapis": "^165.0.0",
    "next": "^14.2.0",
    "pg": "^8.16.3",
    "react": "^18.3.0",
    "react-dom": "^18.3.0"
  },
  "devDependencies": {
    "@types/node": "^24.10.0",
    "@types/react": "^18.3.0",
    "@types/react-dom": "^18.3.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.9.3"
  }
}
</file>

<file path="README.md">
# YouTube Live Chat Fetcher

## Установка

1. Установите зависимости:
   ```
   npm install
   ```
2. Создайте файл `.env` по образцу `.env.example` и заполните:
   - `YOUTUBE_API_KEY` - ключ YouTube Data API v3
   - `YOUTUBE_CHANNEL_ID` - ID вашего канала
   - `PORT` - порт для сервера (по умолчанию 3000)
   - `DB_HOST`, `DB_PORT`, `DB_NAME`, `DB_USER`, `DB_PASSWORD` - параметры подключения к PostgreSQL (опционально)

## Запуск

### Веб-интерфейс

Для отображения чата в браузере:

```
npm run dev
```

Сервер запускается на `http://localhost:3000`, автоматически ищет активную трансляцию канала и отображает сообщения чата в реальном времени.

### Интерфейс для OBS

Для использования чата в OBS Studio через Browser Source:

1. Откройте OBS Studio
2. Добавьте источник "Browser Source"
3. Укажите URL: `http://localhost:3000/obs`
4. Настройте размеры по необходимости

Интерфейс оптимизирован для отображения в OBS с прозрачным фоном и анимацией появления сообщений.

### Получение сообщений из Live Chat

Для получения сообщений из указанного Live Chat в консоль:

```
npm start
```

### Извлечение Live Chat ID из трансляции

Для автоматического поиска активной трансляции канала и извлечения Live Chat ID:

```
npm run test:serejaris
```

Скрипт выполняет следующие действия:
1. Находит канал по handle (по умолчанию `@serejaris`, можно изменить через переменную окружения `YOUTUBE_CHANNEL_HANDLE`)
2. Ищет активную трансляцию канала
3. Извлекает Live Chat ID из трансляции
4. Получает и отображает сообщения из чата трансляции

## Другие команды

- `npm run test:connection` - тестирование подключения к YouTube API
- `npm run get-channel` - получение данных канала

## API Endpoints

### `/api/live-chat-id`
Получение Live Chat ID активной трансляции канала.

### `/api/messages`
Получение сообщений из чата трансляции.
- `liveChatId` (обязательный) - ID чата трансляции
- `pageToken` (опциональный) - токен для пагинации
- `videoId` (опциональный) - ID видео для сохранения в БД

### `/api/messages/stream`
Server-Sent Events (SSE) поток для получения сообщений в реальном времени.
- `liveChatId` (обязательный) - ID чата трансляции
- `videoId` (опциональный) - ID видео для сохранения в БД

### `/api/messages/db`
Получение сообщений из базы данных PostgreSQL.
- `limit` (опциональный, по умолчанию 100) - количество сообщений
- `offset` (опциональный, по умолчанию 0) - смещение для пагинации
- `videoId` (опциональный) - фильтрация по ID видео

## База данных

Приложение автоматически создает таблицу `chat_messages` в PostgreSQL при первом запуске. Все сообщения из чата сохраняются в базу данных для последующей интеграции с другими системами (например, чатом вайб-кодеров).

Схема таблицы:
- `id` - уникальный идентификатор записи
- `message_id` - уникальный ID сообщения из YouTube
- `video_id` - ID видео трансляции
- `live_chat_id` - ID чата трансляции
- `author_name` - имя автора сообщения
- `message_text` - текст сообщения
- `published_at` - время публикации сообщения
- `created_at` - время создания записи в БД
</file>

<file path="components/Navigation.tsx">
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import styles from "./Navigation.module.css";

export default function Navigation() {
  const pathname = usePathname();

  return (
    <nav className={styles.nav}>
      <Link
        href="/transmissions"
        className={`${styles.link} ${pathname === "/transmissions" ? styles.active : ""}`}
      >
        Трансляции
      </Link>
      <Link
        href="/overview"
        className={`${styles.link} ${pathname === "/overview" ? styles.active : ""}`}
      >
        Обзор
      </Link>
      <Link
        href="/videos"
        className={`${styles.link} ${pathname === "/videos" ? styles.active : ""}`}
      >
        Видео
      </Link>
      <Link
        href="/quota"
        className={`${styles.link} ${pathname === "/quota" ? styles.active : ""}`}
      >
        Квота
      </Link>
    </nav>
  );
}
</file>

<file path="src/index.ts">
import dotenv from "dotenv";
import { google } from "googleapis";

dotenv.config();

const apiKey = process.env.YOUTUBE_API_KEY;
const liveChatId = process.env.YOUTUBE_LIVE_CHAT_ID;

if (!apiKey) {
  throw new Error("YOUTUBE_API_KEY отсутствует в окружении");
}

if (!liveChatId) {
  throw new Error("YOUTUBE_LIVE_CHAT_ID отсутствует в окружении");
}

const youtube = google.youtube({ version: "v3", auth: apiKey });

async function sleep(ms: number) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function formatMessage(item: {
  snippet?: { publishedAt?: string | null; displayMessage?: string | null };
  authorDetails?: { displayName?: string | null };
}) {
  const time = item.snippet?.publishedAt
    ? new Date(item.snippet.publishedAt).toLocaleTimeString("ru-RU", { hour12: false })
    : "";
  const author = item.authorDetails?.displayName ?? "Неизвестный автор";
  const text = item.snippet?.displayMessage ?? "";
  return { time, author, text };
}

async function fetchMessages(pageToken?: string) {
  const response = await youtube.liveChatMessages.list({
    liveChatId,
    part: ["id", "snippet", "authorDetails"],
    pageToken,
  });
  return response.data;
}

async function run() {
  let pageToken: string | undefined;
  while (true) {
    const data = await fetchMessages(pageToken);
    const items = data.items ?? [];
    for (const item of items) {
      const formatted = formatMessage(item);
      const pieces = [formatted.time, formatted.author, formatted.text].filter(Boolean);
      if (pieces.length > 0) {
        console.log(pieces.join(" | "));
      }
    }
    pageToken = data.nextPageToken ?? pageToken;
    const delay = data.pollingIntervalMillis ?? 2000;
    await sleep(delay);
  }
}

run().catch((error) => {
  console.error(error instanceof Error ? error.message : error);
  process.exit(1);
});
</file>

<file path="plan.md">
# Лог работы

- ✅ 2025-11-09 14:52:00: Запрос «Я хочу получать данные из моего стрима на YouTube-чате. Помоги мне сделать для этого простое приложение. Все, что оно должно делать, оно должно получать данные из моего YouTube-стрима. Помоги мне, пожалуйста, это сделать. ключ youtube data и пиа и v3 у меня уже есть»; результат: инициализирован Node.js проект, добавлены зависимости и конфигурация, реализован скрипт чтения чата, подготовлена документация.

- ✅ 2025-11-09 14:54:09: Запрос «А протестируй пока без Live Chat ID, пожалуйста.что просто работает уже у нас подключение»; результат: создан тестовый скрипт `src/test-connection.ts` для проверки подключения к YouTube API, добавлен npm скрипт `test:connection`, успешно протестировано подключение - API ключ работает корректно.

- ✅ 2025-11-09 15:54:07: Запрос «Протестируй, пожалуйста, что все работает, что ты можешь получить данные моего канала через API И, пожалуйста, вынеси в env переменную API-ключ»; результат: добавлена поддержка handle в `src/get-channel-data.ts`, создан скрипт `src/test-channel-serejaris.ts`, обновлен `package.json`, расширен `.env.example`, запуск `npm run test:serejaris` подтвердил успешное получение данных канала @serejaris.

- ✅ 2025-11-09 15:53:46: Запрос «Протестируй, пожалуйста, для моего канала получение актуальных данных через YouTube API»; результат: успешно выполнен тест получения данных канала через скрипт `test-channel-serejaris.ts`, получены актуальные данные канала @serejaris: Channel ID UCH6k750mdcOXU6PYHSCOlrA, название "Сережа Рис", 1860 подписчиков, 51 видео, 91791 просмотров, получен список последних 5 видео с актуальными датами публикации, API работает корректно.

- ✅ 2025-11-09 16:00:33: Запрос «излвеки плз мой чат-ид трансляции и протестируй что ты видишь сообщения из него»; результат: расширен скрипт `src/test-channel-serejaris.ts` функциями `getLiveBroadcasts()`, `getLiveChatId()`, `formatMessage()`, `fetchMessages()`, успешно найдена активная трансляция "Вайбкодинг с Cursor" (Video ID: -Fx9QShj_5o), извлечен Live Chat ID: Cg0KCy1GeDlRU2hqXzVvKicKGFVDSDZrNzUwbWRjT1hONlBZSFNDT2xyQRILLUZ4OVFTaGpfNW8, успешно получено и отображено 46 сообщений из чата трансляции, тест подтвердил работоспособность получения сообщений из live chat.

- ✅ 2025-11-09 16:01:32: Запрос «Отлично, добавь, пожалуйста, это в документацию»; результат: обновлен `README.md` с подробным описанием функциональности извлечения Live Chat ID из трансляции, добавлены разделы о запуске скрипта `npm run test:serejaris`, описан процесс автоматического поиска активной трансляции и извлечения chat-id, добавлена информация о других доступных командах проекта.

- ✅ 2025-11-09 17:45:00: Запрос «Собери фронт-энд, страницу, которая будет отображать живой чат из моей трансляции. Поищи в интернете что есть хорошее для этой задачи и реализуй найденный план»; результат: проведено исследование решений YouTube Live Chat, добавлен Express сервер, вынесены утилиты YouTube API, создана веб-страница с polling обновлением чата, обновлена документация.

- ✅ 2025-11-09 16:22:49: Запрос «Добавь, пожалуйста, в ToDo. Во-первых, обновление чата, интерфейс для того, чтобы это поддерживалось в OBS. И интеграция в отправку в Postgre базу данных, которую потом я хочу интегрировать вместе с чатом вайб-кодеров»; результат: добавлены задачи в ToDo, реализовано улучшение обновления чата через SSE endpoint `/api/messages/stream`, создан интерфейс для OBS на странице `/obs` с оптимизированным дизайном для Browser Source, интегрирована PostgreSQL база данных с автоматическим созданием таблицы `chat_messages`, добавлено сохранение всех сообщений в БД при получении через API, создан endpoint `/api/messages/db` для получения сообщений из БД с поддержкой фильтрации по videoId, пагинации и лимитов, обновлены фронтенд и OBS интерфейс для передачи videoId, добавлены переменные окружения для подключения к PostgreSQL (DB_HOST, DB_PORT, DB_NAME, DB_USER, DB_PASSWORD).

- ✅ 2025-11-XX XX:XX:XX: Запрос «я хочу сделать это приложение помощником себе по моему ютуб каналу поэтому помимо того что там уже есть трансляции она должна жить в отдельной так сказать вкладке мне кажется проект будет актуально если его переделать на next.js мне нужна еще отдельная вкладка это обзор моего youtube да статистика по нему»; результат: выполнена миграция проекта на Next.js 14 с App Router, созданы две основные вкладки: "Трансляции" (`/transmissions`) с функционалом live chat и "Обзор" (`/overview`) со статистикой канала (подписчики, просмотры, количество видео), сохранен OBS интерфейс в отдельном роуте `/obs`, мигрированы все API endpoints в `app/api/`, утилиты перенесены в `lib/`, создана навигация между вкладками, обновлены зависимости в `package.json`, удалены старые файлы Express сервера и статические HTML/CSS/JS файлы.

- ✅ 2025-11-10 17:03:07: Запрос «Я заметил, что даже если чат не доступен, API-шка все равно стучится по В общем, приложение стучится по API-шке Нужно проверить, что если во-первых трансляция не включена, то туда не нужно стучаться Если она не открыта, на вкладке нужны Ну и соответственно тоже нужна какая-то кнопка быть, да? Чтобы я это включил»; результат: реализована оптимизация API запросов с использованием лучших практик: разделена логика проверки трансляции и polling сообщений, добавлен exponential backoff для проверки трансляции (5s → 10s → 20s → 30s максимум), реализовано управление таймерами через useRef для предотвращения утечек памяти, добавлена автоматическая остановка запросов при неактивной вкладке через Page Visibility API, добавлена кнопка управления мониторингом с сохранением состояния в localStorage, реализована условная логика перед каждым запросом (проверка isMonitoringEnabled и document.hidden), добавлена поддержка AbortController для отмены fetch запросов. Рефакторинг выполнен для `app/transmissions/page.tsx` и `app/obs/page.tsx`, добавлены стили для кнопки управления мониторингом в `app/transmissions/page.module.css`. Теперь приложение не делает запросы к API когда трансляция не активна, вкладка скрыта или мониторинг выключен пользователем.

- ✅ 2025-11-10 17:07:35: Запрос «Мне нужна возможность редактировать описание для видео. То есть ты должен отобразить последнее моё видео на вкладке видео. Нужна быть новая вкладка видео, и там должны быть в ряд сетка из моих последних видео. Интерфейс должен использовать всю ширину экрана. Описание уже должно быть открыто, то есть я могу, я хочу за раз иметь возможность править много где видео.»; результат: создана новая вкладка "Видео" (`/videos`) с сеткой последних видео канала, расширен `lib/youtube-api.ts` функциями `getChannelVideos()`, `getVideosDetails()` и `getChannelVideosWithDetails()` для получения видео с полными данными включая описания, создан API endpoint `/api/videos` для получения списка видео, реализована страница `app/videos/page.tsx` с адаптивной сеткой видео на всю ширину экрана, каждое видео отображается с миниатюрой, названием, датой публикации и редактируемым полем описания (открыто по умолчанию), добавлена возможность одновременного редактирования описаний нескольких видео, созданы стили `app/videos/page.module.css` с адаптивным дизайном для разных размеров экрана, обновлена навигация `components/Navigation.tsx` с добавлением ссылки на вкладку "Видео".
- ✅ 2025-11-10 17:56:44: Запрос «пожалкуйста проведи иследование потому что все работает в вкладках обзор , не работает только для получения видео. разбеоись в чем дело приложение запущеное на @Browser http://localhost:3000/videos»; результат: воспроизвел обращение к `/api/videos`, зафиксировал ответ 500 с сообщением о превышении квоты YouTube API, установил причину в использовании метода `search.list` (стоимость 100 квотных единиц) и последовательного вызова `videos.list`, что быстро исчерпывает дневную квоту и блокирует загрузку видео на вкладке.
- ✅ 2025-11-10 18:01:04: Запрос «Ну раз такая дорогая цена вызовов то тебе нужно нам нужно сделать все собрать в но по кнопку да вот эти дорогие вызовы уже чтобы не автоматически вызывались а вызывались по кнопке»; результат: обновлен `app/videos/page.tsx` — удален автоматический запрос при монтировании, добавлена кнопка ручной загрузки/обновления списка видео с состояниями `idle/loading`; в `app/videos/page.module.css` добавлены стили `.actions` и `.loadButton`; проверено, что без нажатия запросы не выполняются, а повторный запрос возвращает прежнее сообщение о превышении квоты.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules", "src"]
}
</file>

</files>
